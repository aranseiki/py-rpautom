{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Py-RPAutom","text":"<p>Essa biblioteca tem como objetivo facilitar a cria\u00e7\u00e3o de processos automatizados via c\u00f3digo. Durante a documenta\u00e7\u00e3o ser\u00e1 explicado como utilizar recursos para automa\u00e7\u00e3o web, desktop e recursos do sistema como c\u00f3pia de arquivos ou cria\u00e7\u00e3o de pastas.</p>"},{"location":"dependencias/","title":"Depend\u00eancias","text":"<p>Essa biblioteca usa ferramentas populares para automa\u00e7\u00e3o e testes como Selenium, openpyxl e pywin32.  A lista completa dos requirements voc\u00ea encontra aqui.</p> <p>No entanto, fique tranquilo, basta baixar e instalar a biblioteca que todas as depend\u00eancias ir\u00e3o junto.</p>"},{"location":"historia/","title":"Breve hist\u00f3ria","text":"<p>Py-RPAutom \u00e9 uma biblioteca que nasceu para facilitar o desenvolvimento de rob\u00f4s automatizados, uma vez que precisamos fazer v\u00e1rios c\u00f3digos repetitivos para determinadas a\u00e7\u00f5es. Ainda, a biblioteca \u00e9 feita originalmente em portugu\u00eas para aumentar a inclus\u00e3o da popula\u00e7\u00e3o brasileira. Mesmo que o ingl\u00eas seja o idioma predominantes na \u00e1rea de tecnologia, essa n\u00e3o \u00e9 a realidade da nossa popula\u00e7\u00e3o. Se o objetivo dessa biblioteca \u00e9 facilitar, n\u00e3o faz sentido criar uma barreira idiom\u00e1tica.</p> <p>Tendo origem em 2019, a biblioteca foi desenvolvida de modo separado cada m\u00f3dulo para facilita\u00e7\u00e3o no desenvolvimento de projetos pessoais, mas incorporados rapidamenta ao desenvolvimento profissional. Em 2022, foi a consolida\u00e7\u00e3o dos tr\u00eas m\u00f3dulos b\u00e1sicos at\u00e9 ent\u00e3o (web, desktop e utilit\u00e1rios do sistema), unificando-os e criando assim a sua primeira vers\u00e3o p\u00fablica.</p>"},{"location":"guia_usuario/desktop_utils/","title":"M\u00f3dulo desktop_utils (desktop_utils.py)","text":"<p>Para realizar automa\u00e7\u00f5es em aplica\u00e7\u00f5es desktop, de interface gr\u00e1fica, utilize este m\u00f3dulo. Abaixo, detalhamento das fun\u00e7\u00f5es suas utiliza\u00e7\u00f5es:</p>"},{"location":"guia_usuario/desktop_utils/#estrutura-de-hierarquia-de-um-elemento","title":"Estrutura de hierarquia de um elemento:","text":"<p>Para a intera\u00e7\u00e3o com uma janela ou elemento dentro da aplica\u00e7\u00e3o, \u00e9 necess\u00e1rio informar a \u00e1rvore de elementos at\u00e9 o elemento alvo em formato dict, conforme apresentado abaixo:</p> <pre><code> {\n     'window': {\n         'title': 'nome do elemento',\n         'session': 'nome da sess\u00e3o',\n         'child_window': {\n             'title': 'nome do elemento filho',\n             'control_type': 'tipo de elemento',\n             'auto_id': 'identificador do elemento',\n             'child_window': {\n                 'best_match': 'Outro identificador \u00fanico',\n             }\n         }\n     }\n }\n</code></pre> <p>Onde:</p> <ul> <li> <p>'window': \u00c9 a marca\u00e7\u00e3o que define os par\u00e2metros da janela;</p> </li> <li> <p>'child_window': \u00c9 a marca\u00e7\u00e3o que define os par\u00e2metros dos elementos filhos e filhos de filhos;</p> </li> <li> <p>'session': \u00e9 o nome da sess\u00e3o;</p> </li> <li> <p>'title': \u00e9 o t\u00edtulo da janela ou do elemento;</p> </li> <li> <p>'control_type': \u00e9 o tipo de elemento desktop;</p> </li> <li> <p>'auto_id': \u00e9 o identificador do elemento dentro da aplica\u00e7\u00e3o desktop.</p> </li> <li> <p>'best_match': \u00e9 um identificador \u00fanico, como a classe  do elemento dentro da aplica\u00e7\u00e3o desktop.</p> </li> </ul>"},{"location":"guia_usuario/desktop_utils/#ativando-foco-em-uma-janela","title":"Ativando foco em uma janela","text":"<p>Para colocar a janela em evid\u00eancia, utilize a fun\u00e7\u00e3o <code>ativar_foco</code>. Nela, passe como par\u00e2metro o nome de uma janela que j\u00e1 est\u00e1 em manipula\u00e7\u00e3o pela aplica\u00e7\u00e3o. Isso significa que o nome precisa ser v\u00e1lido dentre as op\u00e7\u00f5es dos nomes de janelas que j\u00e1 s\u00e3o manipul\u00e1veis.</p> <p>A fun\u00e7\u00e3o retorna booleano. Caso o foco d\u00ea certo, <code>True</code>. Caso o foco d\u00ea errado, <code>False</code>.</p>"},{"location":"guia_usuario/desktop_utils/#funcao-ativar_foco","title":"fun\u00e7\u00e3o ativar_foco","text":"<p>Ativa a janela de um objeto do tipo <code>Application</code> deixando-a com foco.</p> <p>Parameters:</p> Name Type Description Default <code>nome_janela</code> <code>str</code> <p>O nome de uma janela j\u00e1 manipul\u00e1vel.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Retorna booleano, <code>True</code> caso o foco tenha sucesso,         <code>False</code> caso o foco n\u00e3o tenha sucesso.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ativar_foco(nome_janela='Untitled - Notepad')\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; ativar_foco(nome_janela='aaaaa')\nFalse\n</code></pre> Source code in <code>py_rpautom\\desktop_utils.py</code> <pre><code>def ativar_foco(nome_janela: str) -&gt; bool:\n    \"\"\"Ativa a janela de um objeto do tipo `Application` deixando-a com foco.\n\n    Parameters:\n        nome_janela: O nome de uma janela j\u00e1 manipul\u00e1vel.\n\n    Returns:\n        Retorna booleano, `True` caso o foco tenha sucesso, \\\n        `False` caso o foco n\u00e3o tenha sucesso.\n\n    Raises:\n        ...\n\n    Examples:\n        &gt;&gt;&gt; ativar_foco(nome_janela='Untitled - Notepad')\n        True\n\n        &gt;&gt;&gt; ativar_foco(nome_janela='aaaaa')\n        False\n    \"\"\"\n\n    # importa app para o escopo da fun\u00e7\u00e3o\n    global APP\n\n    try:\n        # inicializa APP para uma vari\u00e1vel interna\n        app_interno = APP\n\n        # ativa a janela informada\n        app_interno.window(title=nome_janela).set_focus()\n\n        # retorna verdadeiro confirmando a execu\u00e7\u00e3o da a\u00e7\u00e3o\n        return True\n    except:\n        return False\n</code></pre>"},{"location":"guia_usuario/desktop_utils/#verificando-se-um-botao-de-selecao-esta-marcado","title":"Verificando se um bot\u00e3o de sele\u00e7\u00e3o est\u00e1 marcado","text":"<p>Para verificar se um bot\u00e3o de sele\u00e7\u00e3o do tipo checkbox est\u00e1 marcado, utilize a fun\u00e7\u00e3o <code>botao_esta_marcado</code>. Esta fun\u00e7\u00e3o verifica se o bot\u00e3o est\u00e1 selecionado, retornando um valor booleano. <code>True</code> caso o bot\u00e3o estiver selecionado, <code>False</code> caso o bot\u00e3o n\u00e3o estiver selecionado. Para utiliz\u00e1-la, basta no momento da chamada, informar os seguintes dados:</p> <p>caminho at\u00e9 o elemento em formato dict (caminho_campo) :</p> <p>Para informar o caminho do elemento, deve-se seguir a             estrutura de elementos conforme apresendado na sess\u00e3o             \"Estrutura de hierarquia de um elemento\".</p> <p>opcao de verificacao (opcao_verificacao) :</p> <p>Existem 3 tipos de verifica\u00e7\u00f5es:</p> <ul> <li>'IS_CHECKED': \u00c9 a verifica\u00e7\u00e3o pura se est\u00e1 selecionado.</li> <li>'GET_CHECK_STATE': Coleta o estado do elemento (se selecionado ou n\u00e3o).</li> <li>'GET_SHOW_STATE': Coleta a exibi\u00e7\u00e3o gr\u00e1fica do estado do elemento (se selecionado ou n\u00e3o).</li> </ul> <p>A escolha entre cada uma delas vai depender do tipo de elemento que est\u00e1 sendo manipulado. Como cada aplica\u00e7\u00e3o tem um jeito diferente de expor os elementos e seus estados, recomendamos testar cada op\u00e7\u00e3o e verificar o que melhor se encaixa ao momento.</p>"},{"location":"guia_usuario/desktop_utils/#funcao-botao_esta_marcado","title":"fun\u00e7\u00e3o botao_esta_marcado","text":"<p>Verifica se o estado de um bot\u00e3o est\u00e1 como marcado ou n\u00e3o.</p> <p>Parameters:</p> Name Type Description Default <code>caminho_campo</code> <code>dict</code> <p>Caminho do elemento. Precisa ser do tipo dict.</p> required <code>opcao_verificacao</code> <code>str</code> <p>O nome do estado do elemento que se quer             verificar. Aceita as op\u00e7\u00f5es IS_CHECKED, GET_CHECK_STATE             e GET_SHOW_STATE em tipo string.</p> <code>'IS_CHECKED'</code> <p>Returns:</p> Type Description <code>bool</code> <p>Retorna booleano, <code>True</code> caso o bot\u00e3o estiver marcado,         <code>False</code> caso o bot\u00e3o n\u00e3o estiver marcado.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p><code>caminho_campo</code> precisa ser do tipo dict.</p> <code>ValueError</code> <p><code>opcao_verificacao</code> precisa ser do tipo str.</p> <code>ValueError</code> <p>Valores permitidos para <code>opcao_verificacao</code>:             get_check_state, GET_SHOW_STATE, is_checked.</p> Source code in <code>py_rpautom\\desktop_utils.py</code> <pre><code>def botao_esta_marcado(\n    caminho_campo: dict,\n    opcao_verificacao: str = 'IS_CHECKED',\n) -&gt; bool:\n    \"\"\"Verifica se o estado de um bot\u00e3o est\u00e1 como marcado ou n\u00e3o.\n\n    Parameters:\n        caminho_campo: Caminho do elemento. Precisa ser do tipo dict.\n        opcao_verificacao: O nome do estado do elemento que se quer \\\n            verificar. Aceita as op\u00e7\u00f5es IS_CHECKED, GET_CHECK_STATE \\\n            e GET_SHOW_STATE em tipo string.\n\n    Returns:\n        Retorna booleano, `True` caso o bot\u00e3o estiver marcado, \\\n        `False` caso o bot\u00e3o n\u00e3o estiver marcado.\n\n    Raises:\n        ValueError: `caminho_campo` precisa ser do tipo dict.\n\n        ValueError: `opcao_verificacao` precisa ser do tipo str.\n\n        ValueError: \\\n            Valores permitidos para `opcao_verificacao`: \\\n            get_check_state, GET_SHOW_STATE, is_checked.\n\n    \"\"\"\n\n    if isinstance(caminho_campo, dict) is False:\n        raise ValueError('`caminho_campo` precisa ser do tipo dict.')\n\n    if isinstance(opcao_verificacao, str) is False:\n        raise ValueError('`opcao_verificacao` precisa ser do tipo str.')\n\n    # localiza o elemento at\u00e9 o final da \u00e1rvore de parantesco do app\n    app_interno = _localizar_elemento(caminho_campo)\n    app_interno.exists()\n\n    marcado = True\n    if opcao_verificacao.upper() == 'IS_CHECKED':\n        return app_interno.is_checked() == marcado\n    elif opcao_verificacao.upper() == 'GET_CHECK_STATE':\n        return app_interno.get_check_state() == marcado\n    elif opcao_verificacao.upper() == 'GET_SHOW_STATE':\n        return app_interno.get_show_state() == marcado\n    else:\n        raise ValueError(\n            'Valores permitidos para `opcao_verificacao`: '\n            'get_check_state, GET_SHOW_STATE, is_checked.'\n        )\n</code></pre>"},{"location":"guia_usuario/desktop_utils/#capturando-imagem-de-um-elemento","title":"Capturando imagem de um elemento","text":"<p>Existe um recurso para tirar uma imagem do elemento no estado atual da execu\u00e7\u00e3o. Para isso, utilize a fun\u00e7\u00e3o <code>capturar_imagem</code>.</p> <p>Para informar o caminho do elemento, deve-se seguir a             estrutura de elementos conforme apresendado na sess\u00e3o             \"Estrutura de hierarquia de um elemento\".</p>"},{"location":"guia_usuario/desktop_utils/#funcao-capturar_imagem","title":"fun\u00e7\u00e3o capturar_imagem","text":"<p>Captura uma imagem do estado atual do elemento informado e retorna a imagem em bytes.</p> <p>Parameters:</p> Name Type Description Default <code>caminho_campo</code> <code>dict</code> <p>Caminho do elemento na estrutura da aplica\u00e7\u00e3o sendo manipulada.</p> required <code>coordenadas</code> <code>tuple</code> <p>fixar valor da posi\u00e7\u00e3o do elemento. Aceita as posi\u00e7\u00f5es na seguinte ordem: esquerda, cima, direita, baixo.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes</code> <p>Retorna o valor da imagem em tipo bytes.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p><code>caminho_campo</code> precisa ser do tipo dict.</p> <code>ValueError</code> <p><code>coordenadas</code> precisa ser do tipo tuple.</p> <code>ValueError</code> <p><code>coordenadas</code> precisa conter 4 posi\u00e7\u00f5es.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; capturar_imagem(\n        caminho_campo=arvore_do_elemento,\n        coordenadas=(\n            posicao_esquerda,\n            posicao_cima,\n            posicao_direita,\n            posicao_baixo\n        )\n    )\nb'%%&amp;%%&amp;%%&amp;%%&amp;%%&amp;%%&amp;%%&amp;%%&amp;%%&amp;%Jq\\xa1\\xbc\\xcc\\xc7\\xad\\x81K%&amp;%%\n&amp;%%&amp;%%&amp;%%&amp;%%&amp;%%&amp;%%&amp;%%&amp;%%&amp;%%&amp;%:a\\x7f\\x8'\n</code></pre> Source code in <code>py_rpautom\\desktop_utils.py</code> <pre><code>def capturar_imagem(caminho_campo: dict, coordenadas: tuple = None) -&gt; bytes:\n    r\"\"\"\n    Captura uma imagem do estado atual do elemento\n    informado e retorna a imagem em bytes.\n\n    Parameters:\n        caminho_campo: Caminho do elemento na estrutura da aplica\u00e7\u00e3o\n            sendo manipulada.\n        coordenadas: fixar valor da posi\u00e7\u00e3o do elemento. Aceita as\n            posi\u00e7\u00f5es na seguinte ordem: esquerda, cima, direita, baixo.\n\n    Returns:\n        Retorna o valor da imagem em tipo bytes.\n\n    Raises:\n        ValueError: `caminho_campo` precisa ser do tipo dict.\n\n        ValueError: `coordenadas` precisa ser do tipo tuple.\n\n        ValueError: `coordenadas` precisa conter 4 posi\u00e7\u00f5es.\n\n    Examples:\n        &gt;&gt;&gt; capturar_imagem(\n                caminho_campo=arvore_do_elemento,\n                coordenadas=(\n                    posicao_esquerda,\n                    posicao_cima,\n                    posicao_direita,\n                    posicao_baixo\n                )\n            )\n        b'%%&amp;%%&amp;%%&amp;%%&amp;%%&amp;%%&amp;%%&amp;%%&amp;%%&amp;%Jq\\xa1\\xbc\\xcc\\xc7\\xad\\x81K%&amp;%%\n        &amp;%%&amp;%%&amp;%%&amp;%%&amp;%%&amp;%%&amp;%%&amp;%%&amp;%%&amp;%:a\\x7f\\x8'\n    \"\"\"\n\n    # Validar o tipo da varivavel\n    if isinstance(caminho_campo, dict) is False:\n        raise ValueError('`caminho_campo` precisa ser do tipo dict.')\n\n    # Validar o tipo da varivavel\n    if (isinstance(coordenadas, tuple) is False) and (coordenadas is not None):\n        raise ValueError('`coordenadas` precisa ser do tipo tuple.')\n\n    # Capturar o caminho do campo\n    app_interno = _localizar_elemento(caminho_campo=caminho_campo)\n\n    if coordenadas is not None:\n        # Validar a quantidade de dados\n        if not len(coordenadas) == 4:\n            raise ValueError('`coordenadas` precisa conter 4 posi\u00e7\u00f5es.')\n\n        (\n            posicao_esquerda,\n            posicao_cima,\n            posicao_direita,\n            posicao_baixo,\n        ) = coordenadas\n\n        posicao_total = capturar_propriedade_elemento(\n            caminho_campo=caminho_campo\n        )['rectangle']\n\n        posicao_total.left = posicao_esquerda\n        posicao_total.right = posicao_direita\n        posicao_total.top = posicao_cima\n        posicao_total.bottom = posicao_baixo\n\n        # Salvar imagem no caminho solicitado\n        imagem_bytes: bytes = app_interno.capture_as_image(\n            rect=posicao_total\n        ).tobytes()\n    else:\n        # Salvar imagem no caminho solicitado\n        imagem_bytes: bytes = app_interno.capture_as_image().tobytes()\n\n    return imagem_bytes\n</code></pre>"},{"location":"guia_usuario/desktop_utils/#coletando-propriedades-de-um-elemento","title":"Coletando propriedades de um elemento","text":"<p>Algumas vezes ser\u00e3o necess\u00e1rias algumas informa\u00e7\u00f5es, como a posi\u00e7\u00e3o do elemento na aplica\u00e7\u00e3o, se o elemento est\u00e1 em unicode ou mesmo nome da classe ou control_id. Para coletar estas e outras informa\u00e7\u00f5es de um elemento, utilize a fun\u00e7\u00e3o <code>capturar_propriedade_elemento</code>.</p> <p>Para informar o caminho do elemento, deve-se seguir a             estrutura de elementos conforme apresendado na sess\u00e3o             \"Estrutura de hierarquia de um elemento\".</p>"},{"location":"guia_usuario/desktop_utils/#funcao-capturar_propriedade_elemento","title":"fun\u00e7\u00e3o capturar_propriedade_elemento","text":"<p>Captura as propriedades do elemento informado.</p> <p>Parameters:</p> Name Type Description Default <code>caminho_campo</code> <code>dict</code> <p>Caminho do elemento na estrutura da aplica\u00e7\u00e3o             sendo manipulada.</p> required <p>Returns:</p> Type Description <code>dict[str, Union[str, int, bool, list]]</code> <p>Retorna um dicion\u00e1rio contendo string na chave, e um dos valores             a seguir como valor: str, int, bool ou list.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p><code>caminho_campo</code> precisa ser do tipo dict.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; capturar_propriedade_elemento(\n...     caminho_campo={\n...         'window': {\n...             'title': 'Untitled - Notepad',\n...             'child_window': {\n...                 'title': 'DesktopWindowXamlSource',\n...                 'best_match': 'Windows.UI.Composition.DesktopWindowContentBridge2',\n...                 'child_window': {\n...                     'best_match': 'Windows.UI.Input.InputSite.WindowClass2',\n...                 }\n...             }\n...         }\n...     }\n... )\n{'class_name': 'Windows.UI.Input.InputSite.WindowClass', 'friendly_class_name': 'Windows.UI.Input.InputSite.WindowClass', 'texts': [''], 'control_id': 0, 'rectangle': &lt;RECT L961, T562, R961, B562&gt;, 'is_visible': True, 'is_enabled': True, 'control_count': 0, 'style': 1342177280, 'exstyle': 0, 'user_data': 0, 'context_help_id': 0, 'fonts': [&lt;LOGFONTW 'MS Shell Dlg' -13&gt;], 'client_rects': [&lt;RECT L0, T0, R0, B0&gt;], 'is_unicode': True, 'menu_items': [], 'automation_id': ''}\n</code></pre> Source code in <code>py_rpautom\\desktop_utils.py</code> <pre><code>def capturar_propriedade_elemento(\n    caminho_campo: dict,\n) -&gt; dict[str, Union[str, int, bool, list]]:\n    \"\"\"Captura as propriedades do elemento informado.\n\n    Parameters:\n        caminho_campo: Caminho do elemento na estrutura da aplica\u00e7\u00e3o \\\n            sendo manipulada.\n\n    Returns:\n        Retorna um dicion\u00e1rio contendo string na chave, e um dos valores \\\n            a seguir como valor: str, int, bool ou list.\n\n    Raises:\n        ValueError: `caminho_campo` precisa ser do tipo dict.\n\n    Examples:\n        &gt;&gt;&gt; capturar_propriedade_elemento(\n        ...     caminho_campo={\n        ...         'window': {\n        ...             'title': 'Untitled - Notepad',\n        ...             'child_window': {\n        ...                 'title': 'DesktopWindowXamlSource',\n        ...                 'best_match': 'Windows.UI.Composition.DesktopWindowContentBridge2',\n        ...                 'child_window': {\n        ...                     'best_match': 'Windows.UI.Input.InputSite.WindowClass2',\n        ...                 }\n        ...             }\n        ...         }\n        ...     }\n        ... )\n        {'class_name': 'Windows.UI.Input.InputSite.WindowClass', 'friendly_class_name': 'Windows.UI.Input.InputSite.WindowClass', 'texts': [''], 'control_id': 0, 'rectangle': &lt;RECT L961, T562, R961, B562&gt;, 'is_visible': True, 'is_enabled': True, 'control_count': 0, 'style': 1342177280, 'exstyle': 0, 'user_data': 0, 'context_help_id': 0, 'fonts': [&lt;LOGFONTW 'MS Shell Dlg' -13&gt;], 'client_rects': [&lt;RECT L0, T0, R0, B0&gt;], 'is_unicode': True, 'menu_items': [], 'automation_id': ''}\n    \"\"\"\n\n    # Validar o tipo da varivavel\n    if isinstance(caminho_campo, dict) is False:\n        raise ValueError('`caminho_campo` precisa ser do tipo dict.')\n\n    # Capturar o caminho do campo\n    app_interno = _localizar_elemento(caminho_campo=caminho_campo)\n\n    # Capturar propriedade do campo\n    dado = app_interno.get_properties()\n\n    return dado\n</code></pre>"},{"location":"guia_usuario/desktop_utils/#coletando-o-texto-de-um-elemento","title":"Coletando o texto de um elemento","text":"<p>Um recurso muito comum \u00e9 a captura de texto de um elemento. Para este feito, utilize a fun\u00e7\u00e3o <code>capturar_texto</code>.</p> <p>Para informar o caminho do elemento, deve-se seguir a             estrutura de elementos conforme apresendado na sess\u00e3o             \"Estrutura de hierarquia de um elemento\".</p>"},{"location":"guia_usuario/desktop_utils/#funcao-capturar_texto","title":"fun\u00e7\u00e3o capturar_texto","text":"<p>Captura o texto de um elemento dentro de um objeto do tipo Application.</p> <p>Parameters:</p> Name Type Description Default <code>caminho_campo</code> <code>dict</code> <p>Caminho do elemento na estrutura da aplica\u00e7\u00e3o             sendo manipulada.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>Retorna uma lista de strings, sendo o valor capturado do elemento             informado.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p><code>caminho_campo</code> precisa ser do tipo dict.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; capturar_texto(\n...     caminho_campo={\n...         'window': {\n...             'title': 'Windows Powershell Main Window',\n...             'child_window': {\n...                 'title': 'Windows Powershell Main Menu',\n...                 'child_window': {\n...                     'title': 'File',\n...                 }\n...             }\n...         }\n...     },\n... )\n['File']\n</code></pre> Source code in <code>py_rpautom\\desktop_utils.py</code> <pre><code>def capturar_texto(caminho_campo: dict) -&gt; list[str]:\n    \"\"\"Captura o texto de um elemento dentro de um objeto do tipo Application.\n\n    Parameters:\n        caminho_campo: Caminho do elemento na estrutura da aplica\u00e7\u00e3o \\\n            sendo manipulada.\n\n    Returns:\n        Retorna uma lista de strings, sendo o valor capturado do elemento \\\n            informado.\n\n    Raises:\n        ValueError: `caminho_campo` precisa ser do tipo dict.\n\n\n    Examples:\n        &gt;&gt;&gt; capturar_texto(\n        ...     caminho_campo={\n        ...         'window': {\n        ...             'title': 'Windows Powershell Main Window',\n        ...             'child_window': {\n        ...                 'title': 'Windows Powershell Main Menu',\n        ...                 'child_window': {\n        ...                     'title': 'File',\n        ...                 }\n        ...             }\n        ...         }\n        ...     },\n        ... )\n        ['File']\n    \"\"\"\n\n    if isinstance(caminho_campo, dict) is False:\n        raise ValueError('`caminho_campo` precisa ser do tipo dict.')\n\n    # localiza o elemento at\u00e9 o final da \u00e1rvore de parantesco do app\n    app_interno = _localizar_elemento(caminho_campo)\n    app_interno.exists()\n\n    # captura o texto do campo localizado\n    valor_capturado: list = app_interno.texts()\n\n    # retorna o valor capturado\n    return valor_capturado\n</code></pre>"},{"location":"guia_usuario/desktop_utils/#clicando-em-um-elemento","title":"Clicando em um elemento","text":"<p>Para realizar o clique em um elemento dentro da aplica\u00e7\u00e3o, utilize a fun\u00e7\u00e3o <code>clicar</code>.</p> <p>Para informar o caminho do elemento, deve-se seguir a             estrutura de elementos conforme apresendado na sess\u00e3o             \"Estrutura de hierarquia de um elemento\".</p>"},{"location":"guia_usuario/desktop_utils/#funcao-clicar","title":"fun\u00e7\u00e3o clicar","text":"<p>Clica em um elemento dentro de um objeto do tipo Application.</p> <p>Parameters:</p> Name Type Description Default <code>caminho_campo</code> <code>dict</code> <p>Caminho do elemento na estrutura da aplica\u00e7\u00e3o             sendo manipulada.</p> required <code>performar</code> <code>bool</code> <p>Ativa clique f\u00edsico direto no elemento informado.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>Retorna <code>True</code> caso chegue ao final do clique.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p><code>caminho_campo</code> precisa ser do tipo dict.</p> <code>ValueError</code> <p><code>performar</code> precisa ser do tipo boleano.'</p> <code>ValueError</code> <p><code>indice</code> precisa ser do tipo int.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; clicar(\n...     caminho_campo={\n...         'window': {\n...             'title': 'Windows Powershell Main Window',\n...             'child_window': {\n...                 'title': 'Windows Powershell Main Menu',\n...                 'child_window': {\n...                     'title': 'File',\n...                 }\n...             }\n...         }\n...     },\n...     indice=0,\n...     performar=True,\n... )\nTrue\n</code></pre> Source code in <code>py_rpautom\\desktop_utils.py</code> <pre><code>def clicar(\n    caminho_campo: dict,\n    performar: bool = False,\n    indice: int = None,\n) -&gt; bool:\n    \"\"\"Clica em um elemento dentro de um objeto do tipo Application.\n\n    Parameters:\n        caminho_campo: Caminho do elemento na estrutura da aplica\u00e7\u00e3o \\\n            sendo manipulada.\n        performar: Ativa clique f\u00edsico direto no elemento informado.\n\n    Returns:\n        Retorna `True` caso chegue ao final do clique.\n\n    Raises:\n        ValueError: `caminho_campo` precisa ser do tipo dict.\n        ValueError: `performar` precisa ser do tipo boleano.'\n        ValueError: `indice` precisa ser do tipo int.\n\n\n    Examples:\n        &gt;&gt;&gt; clicar(\n        ...     caminho_campo={\n        ...         'window': {\n        ...             'title': 'Windows Powershell Main Window',\n        ...             'child_window': {\n        ...                 'title': 'Windows Powershell Main Menu',\n        ...                 'child_window': {\n        ...                     'title': 'File',\n        ...                 }\n        ...             }\n        ...         }\n        ...     },\n        ...     indice=0,\n        ...     performar=True,\n        ... )\n        True\n    \"\"\"\n\n    # localiza o elemento at\u00e9 o final da \u00e1rvore de parantesco do app\n    if isinstance(caminho_campo, dict) is False:\n        raise ValueError('`caminho_campo` precisa ser do tipo dict.')\n\n    if isinstance(performar, bool) is False:\n        raise ValueError('`performar` precisa ser do tipo boleano.')\n\n    if isinstance(indice, int) is False and indice is not None:\n        raise ValueError('`indice` precisa ser do tipo int.')\n\n    app_interno = _localizar_elemento(caminho_campo)\n    app_interno.exists()\n\n    if indice is not None:\n        app_interno = app_interno.children()[indice]\n\n    # digita o valor no campo localizado\n    if performar is True:\n        app_interno.click_input()\n    else:\n        app_interno.click()\n\n    # retorna o valor capturado e tratado\n    return True\n</code></pre>"},{"location":"guia_usuario/desktop_utils/#coletando-a-arvore-de-elementos-de-uma-janela-ou-elemento","title":"Coletando a \u00e1rvore de elementos de uma janela ou elemento","text":"<p>Utilizando a fun\u00e7\u00e3o <code>coletar_arvore_elementos</code>, \u00e9 poss\u00edvel verificar quais elementos comp\u00f5em uma janela ou um elemento espec\u00edfico. A abordagem \u00e9 \u00fanica para ambos os casos.</p> <p>Uma \u00e1rvore de elementos \u00e9 a estrutura hier\u00e1rquica dos elementos em uma aplica\u00e7\u00e3o. Dentro de uma janela h\u00e1 elementos. Esses elementos podem ou n\u00e3o conter elementos dentro de si. Isso vai compondo uma hierarquiza\u00e7\u00e3o de elementos, um dentro de outro, ao lado de outro e assim por diante.</p> <p>Assim, para visualizar a estrutura de um elemento ou de uma janela, recorra \u00e0 fun\u00e7\u00e3o coletar_arvore_elementos. Ela retorna, em string, os elementos dentro do que foi solicitado. Caso, por exemplo, seja informado no par\u00e2metro <code>caminho_elemento</code> uma janela, ser\u00e1 retornado todos os elementos vis\u00edveis dessa janela no momento da execu\u00e7\u00e3o do comando. O mesmo acontece caso seja passado um elemento.</p> <p>Para informar o caminho do elemento, deve-se seguir a             estrutura de elementos conforme apresendado na sess\u00e3o             \"Estrutura de hierarquia de um elemento\".</p>"},{"location":"guia_usuario/desktop_utils/#funcao-coletar_arvore_elementos","title":"fun\u00e7\u00e3o coletar_arvore_elementos","text":"<p>Lista um elemento dentro de um objeto do tipo Application e retorna         o valor coletado.</p> <p>Parameters:</p> Name Type Description Default <code>caminho_elemento</code> <code>dict</code> <p>Caminho do elemento na estrutura da aplica\u00e7\u00e3o             sendo manipulada.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>Retorna uma lista de strings, sendo o valor capturado do elemento             informado.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p><code>caminho_elemento</code> precisa ser do tipo dict.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; coletar_arvore_elementos(\n...     caminho_elemento={\n...         'window': {\n...             'title': 'Untitled - Notepad',\n...             'child_window': {\n...                 'title': 'DesktopWindowXamlSource',\n...                 'best_match': 'Windows.UI.Composition.DesktopWindowContentBridge2',\n...                 'child_window': {\n...                     'best_match': 'Windows.UI.Input.InputSite.WindowClass2',\n...                 }\n...             }\n...         }\n...     }\n... )\n['Control Identifiers:', '', \"Windows.UI.Input.InputSite.WindowClass - ''    (L1898, T603, R1898, B603)\", \"['Windows.UI.Input.InputSite.WindowClass']\", 'child_window(class_name=\"Windows.UI.Input.InputSite.WindowClass\")', '']\n</code></pre> Source code in <code>py_rpautom\\desktop_utils.py</code> <pre><code>def coletar_arvore_elementos(caminho_elemento: dict) -&gt; list[str]:\n    \"\"\"Lista um elemento dentro de um objeto do tipo Application e retorna \\\n        o valor coletado.\n\n    Parameters:\n        caminho_elemento: Caminho do elemento na estrutura da aplica\u00e7\u00e3o \\\n            sendo manipulada.\n\n    Returns:\n        Retorna uma lista de strings, sendo o valor capturado do elemento \\\n            informado.\n\n    Raises:\n        ValueError: `caminho_elemento` precisa ser do tipo dict.\n\n    Examples:\n        &gt;&gt;&gt; coletar_arvore_elementos(\n        ...     caminho_elemento={\n        ...         'window': {\n        ...             'title': 'Untitled - Notepad',\n        ...             'child_window': {\n        ...                 'title': 'DesktopWindowXamlSource',\n        ...                 'best_match': 'Windows.UI.Composition.DesktopWindowContentBridge2',\n        ...                 'child_window': {\n        ...                     'best_match': 'Windows.UI.Input.InputSite.WindowClass2',\n        ...                 }\n        ...             }\n        ...         }\n        ...     }\n        ... )\n        ['Control Identifiers:', '', \"Windows.UI.Input.InputSite.WindowClass - ''    (L1898, T603, R1898, B603)\", \"['Windows.UI.Input.InputSite.WindowClass']\", 'child_window(class_name=\"Windows.UI.Input.InputSite.WindowClass\")', '']\n    \"\"\"\n\n    # importa recursos do m\u00f3dulo io\n    import io\n\n    # importa recursos do m\u00f3dulo Path\n    from contextlib import redirect_stdout\n\n    if isinstance(caminho_elemento, dict) is False:\n        raise ValueError('`caminho_elemento` precisa ser do tipo dict.')\n\n    # localiza o elemento at\u00e9 o final da \u00e1rvore de parantesco do app\n    app_interno = _localizar_elemento(caminho_elemento)\n    app_interno.exists()\n\n    conteudoStdOut = io.StringIO()\n    with redirect_stdout(conteudoStdOut):\n        app_interno.print_control_identifiers()\n\n    valor = conteudoStdOut.getvalue()\n    valor_dividido = valor.split('\\n')\n\n    # retorna o valor capturado e tratado\n    return valor_dividido\n</code></pre>"},{"location":"guia_usuario/desktop_utils/#coletando-valor-selecionado-de-um-campo-de-selecao","title":"Coletando valor selecionado de um campo de sele\u00e7\u00e3o","text":"<p>Um campo de sele\u00e7\u00e3o, elemento do tipo combobox, sempre cont\u00e9m alguma op\u00e7\u00e3o selecionada, mesmo que seja um valor vazio ou definido por padr\u00e3o pela aplica\u00e7\u00e3o. Caso queira coletar o valor de um campo de sele\u00e7\u00e3o, utilize a fun\u00e7\u00e3o abaixo, que retornar\u00e1 o valor do campo informado no momento de sua execu\u00e7\u00e3o.</p> <p>Para informar o caminho do elemento, deve-se seguir a             estrutura de elementos conforme apresendado na sess\u00e3o             \"Estrutura de hierarquia de um elemento\".</p>"},{"location":"guia_usuario/desktop_utils/#funcao-coletar_dado_selecionado","title":"fun\u00e7\u00e3o coletar_dado_selecionado","text":"<p>Coleta a op\u00e7\u00e3o atualmente selecionada em um elemento de sele\u00e7\u00e3o de         um objeto do tipo Application.</p> <p>Parameters:</p> Name Type Description Default <code>caminho_campo</code> <code>dict</code> <p>Caminho do elemento na estrutura da aplica\u00e7\u00e3o             sendo manipulada.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Retorna uma string, sendo o valor capturado do elemento informado.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p><code>caminho_campo</code> precisa ser do tipo dict.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; coletar_dado_selecionado(\n...     caminho_campo={\n...         'window': {\n...             'title': 'Character Map',\n...             'child_window': {\n...                 'title': 'Font :',\n...                 'control_type': 'ComboBox',\n...                 'auto_id': '105',\n...             }\n...         }\n...     },\n... )\n'Arial'\n</code></pre> Source code in <code>py_rpautom\\desktop_utils.py</code> <pre><code>def coletar_dado_selecionado(caminho_campo: dict) -&gt; str:\n    \"\"\"Coleta a op\u00e7\u00e3o atualmente selecionada em um elemento de sele\u00e7\u00e3o de \\\n        um objeto do tipo Application.\n\n    Parameters:\n        caminho_campo: Caminho do elemento na estrutura da aplica\u00e7\u00e3o \\\n            sendo manipulada.\n\n    Returns:\n        Retorna uma string, sendo o valor capturado do elemento informado.\n\n    Raises:\n        ValueError: `caminho_campo` precisa ser do tipo dict.\n\n    Examples:\n        &gt;&gt;&gt; coletar_dado_selecionado(\n        ...     caminho_campo={\n        ...         'window': {\n        ...             'title': 'Character Map',\n        ...             'child_window': {\n        ...                 'title': 'Font :',\n        ...                 'control_type': 'ComboBox',\n        ...                 'auto_id': '105',\n        ...             }\n        ...         }\n        ...     },\n        ... )\n        'Arial'\n    \"\"\"\n\n    # define est\u00e1tico como falso para trabalhar com elemento din\u00e2mico\n    if isinstance(caminho_campo, dict) is False:\n        raise ValueError('`caminho_campo` precisa ser do tipo dict.')\n\n    # localiza o elemento at\u00e9 o final da \u00e1rvore de parantesco do app\n    app_interno = _localizar_elemento(caminho_campo)\n    app_interno.exists()\n\n    # captura o texto do campo localizado\n    valor_capturado: str = app_interno.selected_text()\n\n    # retorna o valor capturado\n    return valor_capturado\n</code></pre>"},{"location":"guia_usuario/desktop_utils/#coletando-valores-disponiveis-de-um-campo-de-selecao","title":"Coletando valores dispon\u00edveis de um campo de sele\u00e7\u00e3o","text":"<p>Assim como um campo de sele\u00e7\u00e3o, elemento do tipo combobox, cont\u00e9m alguma op\u00e7\u00e3o selecionada, tamb\u00e9m contem uma ou mais op\u00e7\u00f5es para selecionar. Para coletar todos os valores dispon\u00edveis em um campo de sele\u00e7\u00e3o, utilize a fun\u00e7\u00e3o abaixo, que retornar\u00e1, em string, as op\u00e7\u00f5es de sele\u00e7\u00e3o do elemento solicitado no momento de sua execu\u00e7\u00e3o.</p> <p>Para informar o caminho do elemento, deve-se seguir a             estrutura de elementos conforme apresendado na sess\u00e3o             \"Estrutura de hierarquia de um elemento\".</p>"},{"location":"guia_usuario/desktop_utils/#funcao-coletar_dados_selecao","title":"fun\u00e7\u00e3o coletar_dados_selecao","text":"<p>Coleta todas as op\u00e7\u00f5es dispon\u00edveis para sele\u00e7\u00e3o em um elemento de         sele\u00e7\u00e3o de um objeto do tipo Application.</p> <p>Parameters:</p> Name Type Description Default <code>caminho_campo</code> <code>dict</code> <p>Caminho do elemento na estrutura da aplica\u00e7\u00e3o             sendo manipulada.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Retorna uma string, sendo o valor capturado do elemento informado.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p><code>caminho_campo</code> precisa ser do tipo dict.</p> <p>Examples:</p> <p>...</p> Source code in <code>py_rpautom\\desktop_utils.py</code> <pre><code>def coletar_dados_selecao(caminho_campo: dict) -&gt; str:\n    \"\"\"Coleta todas as op\u00e7\u00f5es dispon\u00edveis para sele\u00e7\u00e3o em um elemento de \\\n        sele\u00e7\u00e3o de um objeto do tipo Application.\n\n    Parameters:\n        caminho_campo: Caminho do elemento na estrutura da aplica\u00e7\u00e3o \\\n            sendo manipulada.\n\n    Returns:\n        Retorna uma string, sendo o valor capturado do elemento informado.\n\n    Raises:\n        ValueError: `caminho_campo` precisa ser do tipo dict.\n\n    Examples:\n        ...\n    \"\"\"\n\n    # define est\u00e1tico como falso para trabalhar com elemento din\u00e2mico\n    if isinstance(caminho_campo, dict) is False:\n        raise ValueError('`caminho_campo` precisa ser do tipo dict.')\n\n    # localiza o elemento at\u00e9 o final da \u00e1rvore de parantesco do app\n    app_interno = _localizar_elemento(caminho_campo)\n    app_interno.exists()\n\n    # captura o texto do campo localizado\n    valor_capturado: str = app_interno.item_texts()\n\n    # retorna o valor capturado\n    return valor_capturado\n</code></pre>"},{"location":"guia_usuario/desktop_utils/#coletando-o-estado-atual-da-janela","title":"Coletando o estado atual da janela","text":"<p>As janelas de uma aplica\u00e7\u00e3o dentro de um sistema operacional tem estados padr\u00f5es, como estar minimizado ou em modo normal. Estes e outros estados podem ser capturados utilizando a fun\u00e7\u00e3o <code>coletar_situacao_janela</code> no momento de sua execu\u00e7\u00e3o.</p> <p>Para informar o caminho do elemento, deve-se seguir a             estrutura de elementos conforme apresendado na sess\u00e3o             \"Estrutura de hierarquia de um elemento\".</p>"},{"location":"guia_usuario/desktop_utils/#funcao-coletar_situacao_janela","title":"fun\u00e7\u00e3o coletar_situacao_janela","text":"<p>Coleta a situa\u00e7\u00e3o do estado atual de uma janela de um objeto do tipo Application.</p> <p>Parameters:</p> Name Type Description Default <code>caminho_janela</code> <code>dict</code> <p>Caminho da janela na estrutura da aplica\u00e7\u00e3o             sendo manipulada.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Retorna uma string, sendo um dos valores a seguir: 'normal', 'minimizado', 'maximizado' e 'n\u00e3o identificado'.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p><code>caminho_janela</code> precisa ser do tipo dict.</p> <p>Examples:</p>"},{"location":"guia_usuario/desktop_utils/#desktop_utils.coletar_situacao_janela--validacao-com-a-janela-restaurada-no-momento-da-execucao-do-comando","title":"Valida\u00e7\u00e3o com a janela restaurada no momento da execu\u00e7\u00e3o do comando","text":"<pre><code>&gt;&gt;&gt; coletar_situacao_janela(\n...     caminho_janela={\n...         'window': {\n...             'title': 'Untitled - Notepad',\n...         }\n...     }\n... )\n'normal'\n</code></pre>"},{"location":"guia_usuario/desktop_utils/#desktop_utils.coletar_situacao_janela--validacao-com-a-janela-maximizada-no-momento-da-execucao-do-comando","title":"Valida\u00e7\u00e3o com a janela maximizada no momento da execu\u00e7\u00e3o do comando","text":"<pre><code>&gt;&gt;&gt; coletar_situacao_janela(\n...     caminho_janela={\n...         'window': {\n...             'title': 'Untitled - Notepad',\n...         }\n...     }\n... )\n'maximizado'\n</code></pre>"},{"location":"guia_usuario/desktop_utils/#desktop_utils.coletar_situacao_janela--validacao-com-a-janela-minimizaa-no-momento-da-execucao-do-comando","title":"Valida\u00e7\u00e3o com a janela minimizaa no momento da execu\u00e7\u00e3o do comando","text":"<pre><code>&gt;&gt;&gt; coletar_situacao_janela(\n...     caminho_janela={\n...         'window': {\n...             'title': 'Untitled - Notepad',\n...         }\n...     }\n... )\n'minimizado'\n</code></pre> Source code in <code>py_rpautom\\desktop_utils.py</code> <pre><code>def coletar_situacao_janela(caminho_janela: dict) -&gt; str:\n    \"\"\"Coleta a situa\u00e7\u00e3o do estado atual de uma janela de um objeto do tipo Application.\n\n    Parameters:\n        caminho_janela: Caminho da janela na estrutura da aplica\u00e7\u00e3o \\\n            sendo manipulada.\n\n    Returns:\n        Retorna uma string, sendo um dos valores a seguir: 'normal', 'minimizado', 'maximizado' e 'n\u00e3o identificado'.\n\n    Raises:\n        ValueError: `caminho_janela` precisa ser do tipo dict.\n\n    Examples:\n        #### Valida\u00e7\u00e3o com a janela restaurada no momento da execu\u00e7\u00e3o do comando\n        &gt;&gt;&gt; coletar_situacao_janela(\n        ...     caminho_janela={\n        ...         'window': {\n        ...             'title': 'Untitled - Notepad',\n        ...         }\n        ...     }\n        ... )\n        'normal'\n\n        #### Valida\u00e7\u00e3o com a janela maximizada no momento da execu\u00e7\u00e3o do comando\n        &gt;&gt;&gt; coletar_situacao_janela(\n        ...     caminho_janela={\n        ...         'window': {\n        ...             'title': 'Untitled - Notepad',\n        ...         }\n        ...     }\n        ... )\n        'maximizado'\n\n        #### Valida\u00e7\u00e3o com a janela minimizaa no momento da execu\u00e7\u00e3o do comando\n        &gt;&gt;&gt; coletar_situacao_janela(\n        ...     caminho_janela={\n        ...         'window': {\n        ...             'title': 'Untitled - Notepad',\n        ...         }\n        ...     }\n        ... )\n        'minimizado'\n    \"\"\"\n\n    # importa app para o escopo da fun\u00e7\u00e3o\n    global APP\n\n    if isinstance(caminho_janela, dict) is False:\n        raise ValueError('`caminho_janela` precisa ser do tipo dict.')\n\n    # inicializa APP para uma vari\u00e1vel interna\n    app_interno = APP\n\n    situacao = ''\n    # coleta a situacao atual da janela\n    app_interno = _localizar_elemento(caminho_janela)\n    app_interno.exists()\n    situacao_temp = app_interno.get_show_state()\n\n    # 1 - Normal\n    # 2 - Minimizado\n    # 3 - Maximizado\n    # Caso n\u00e3o encontre as situa\u00e7\u00f5es normal, ninimizado e\n    #   maximizado, define um valor padr\u00e3o.\n    if situacao_temp == 1:\n        situacao = 'normal'\n    elif situacao_temp == 2:\n        situacao = 'minimizado'\n    elif situacao_temp == 3:\n        situacao = 'maximizado'\n    else:\n        situacao = 'n\u00e3o identificado'\n\n    # retorna a situa\u00e7\u00e3o da janela\n    return situacao\n</code></pre>"},{"location":"guia_usuario/desktop_utils/#conectando-se-a-uma-aplicacao-ja-em-execucao","title":"Conectando-se \u00e0 uma aplica\u00e7\u00e3o j\u00e1 em execu\u00e7\u00e3o","text":"<p>\u00c9 poss\u00edvel manipular aplica\u00e7\u00f5es j\u00e1 em execu\u00e7\u00e3o. Para isso, utilize a fun\u00e7\u00e3o <code>conectar_app</code>, que adicionar\u00e1 a aplica\u00e7\u00e3o ao conjunto de aplica\u00e7\u00f5es manipul\u00e1veis e retornar\u00e1 o PID da mesma.</p>"},{"location":"guia_usuario/desktop_utils/#funcao-conectar_app","title":"fun\u00e7\u00e3o conectar_app","text":"<p>Torna um processo do sistema j\u00e1 existente como um objeto do tipo         Application manipul\u00e1vel.</p> <p>Parameters:</p> Name Type Description Default <code>pid</code> <code>int</code> <p>PID do processo existente.</p> required <code>tempo_espera</code> <code>int</code> <p>Tempo limite em segundos para o in\u00edcio do processo.</p> <code>60</code> <code>estilo_aplicacao</code> <code>str</code> <p>Estilo de aplica\u00e7\u00e3o a ser manipulado, sendo             'win32' e 'uia' os valores aceitos.</p> <code>'win32'</code> <p>Returns:</p> Type Description <code>int</code> <p>Retorna int, sendo o PID do processo manipulado.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; conectar_app(\n...     pid=notepad_pid,\n...     tempo_espera=10,\n...     estilo_aplicacao='win32',\n... )\n33144\n</code></pre> Source code in <code>py_rpautom\\desktop_utils.py</code> <pre><code>def conectar_app(\n    pid: int,\n    tempo_espera: int = 60,\n    estilo_aplicacao: str = 'win32',\n) -&gt; int:\n    \"\"\"Torna um processo do sistema j\u00e1 existente como um objeto do tipo \\\n        Application manipul\u00e1vel.\n\n    Parameters:\n        pid: PID do processo existente.\n        tempo_espera: Tempo limite em segundos para o in\u00edcio do processo.\n        estilo_aplicacao: Estilo de aplica\u00e7\u00e3o a ser manipulado, sendo \\\n            'win32' e 'uia' os valores aceitos.\n\n    Returns:\n        Retorna int, sendo o PID do processo manipulado.\n\n    Raises:\n        ...\n\n    Examples:\n        &gt;&gt;&gt; conectar_app(\n        ...     pid=notepad_pid,\n        ...     tempo_espera=10,\n        ...     estilo_aplicacao='win32',\n        ... )\n        33144\n    \"\"\"\n\n    # define app como global\n    global APP\n    global ESTILO_APLICACAO\n\n    ESTILO_APLICACAO = estilo_aplicacao\n\n    # instancia o objeto application\n    APP = _aplicacao(estilo_aplicacao=ESTILO_APLICACAO)\n\n    # inicia o processo de execu\u00e7\u00e3o do aplicativo passado como par\u00e2metro\n    app_conectado: Application = _conectar_app(\n        pid=pid,\n        tempo_espera=tempo_espera,\n        estilo_aplicacao=ESTILO_APLICACAO,\n    )\n\n    # coleta o PID da aplica\u00e7\u00e3o instanciada\n    processo_app: int = app_conectado.process\n\n    # retorna o PID coletado\n    return processo_app\n</code></pre> <p>Escolha o estilo da aplica\u00e7\u00e3o, Win32 ou UIA, de acordo com a arquitetura da aplica\u00e7\u00e3o que se quer manipular. Aplica\u00e7\u00f5es Win32 s\u00e3o aplica\u00e7\u00f5es no estilo cl\u00e1ssico do Windows, j\u00e1 aplica\u00e7\u00f5es UIA s\u00e3o aplica\u00e7\u00f5es modernas, em sua maioria disponibilizadas a partir da loja do Windows. Recomendamos que, em caso de d\u00favidas, teste as possibilidades e escolha o que melhor se adequa ao momento.</p>"},{"location":"guia_usuario/desktop_utils/#digitando-em-um-elemento","title":"Digitando em um elemento","text":"<p>Para escrever algum texto ou n\u00famero em um elemento, utilize a fun\u00e7\u00e3o <code>digitar</code>. Em caso de n\u00famero, deve ser enviado em formato string.</p> <p>Para informar o caminho do elemento, deve-se seguir a             estrutura de elementos conforme apresendado na sess\u00e3o             \"Estrutura de hierarquia de um elemento\".</p>"},{"location":"guia_usuario/desktop_utils/#funcao-digitar","title":"fun\u00e7\u00e3o digitar","text":"<p>Digita em um elemento dentro de um objeto do tipo Application.</p> <p>Parameters:</p> Name Type Description Default <code>caminho_campo</code> <code>dict</code> <p>Caminho do elemento na estrutura da aplica\u00e7\u00e3o             sendo manipulada.</p> required <code>valor</code> <code>str</code> <p>O valor a ser digitado.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Retorna str, sendo o valor do campo ap\u00f3s a inser\u00e7\u00e3o do valor             informado.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p><code>caminho_campo</code> precisa ser do tipo dict.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; digitar(\n...     caminho_campo={\n...         'window': {\n...             'title': 'Character Map',\n...             'child_window': {\n...                 'control_type': 'Edit',\n...                 'auto_id': '104',\n...             }\n...         }\n...     },\n...     valor='ABCDE',\n... )\n\"['ABCDE']\"\n</code></pre> Source code in <code>py_rpautom\\desktop_utils.py</code> <pre><code>def digitar(\n    caminho_campo: dict,\n    valor: str,\n) -&gt; str:\n    \"\"\"Digita em um elemento dentro de um objeto do tipo Application.\n\n    Parameters:\n        caminho_campo: Caminho do elemento na estrutura da aplica\u00e7\u00e3o \\\n            sendo manipulada.\n        valor: O valor a ser digitado.\n\n    Returns:\n        Retorna str, sendo o valor do campo ap\u00f3s a inser\u00e7\u00e3o do valor \\\n            informado.\n\n    Raises:\n        ValueError: `caminho_campo` precisa ser do tipo dict.\n\n\n    Examples:\n        &gt;&gt;&gt; digitar(\n        ...     caminho_campo={\n        ...         'window': {\n        ...             'title': 'Character Map',\n        ...             'child_window': {\n        ...                 'control_type': 'Edit',\n        ...                 'auto_id': '104',\n        ...             }\n        ...         }\n        ...     },\n        ...     valor='ABCDE',\n        ... )\n        \"['ABCDE']\"\n    \"\"\"\n\n    if isinstance(caminho_campo, dict) is False:\n        raise ValueError('`caminho_campo` precisa ser do tipo dict.')\n\n    # localiza o elemento at\u00e9 o final da \u00e1rvore de parantesco do app\n    app_interno = _localizar_elemento(caminho_campo)\n    app_interno.exists()\n\n    # digita o valor no campo localizado\n    app_interno.set_edit_text(\n        text=valor,\n    )\n\n    # trata o valor capturado conforme o tipo do valor de entrada\n    valor_retornado = str(capturar_texto(caminho_campo))\n\n    # retorna o valor capturado e tratado\n    return valor_retornado\n</code></pre>"},{"location":"guia_usuario/desktop_utils/#fechando-uma-aplicacao","title":"Fechando uma aplica\u00e7\u00e3o","text":"<p>Para fechar uma aplica\u00e7\u00e3o e todas as suas janelas abertas, utilize a fun\u00e7\u00e3o <code>encerrar_app</code>.</p>"},{"location":"guia_usuario/desktop_utils/#funcao-encerrar_app","title":"fun\u00e7\u00e3o encerrar_app","text":"<p>Encerra um processo do sistema de um objeto do tipo Application         sendo manipulado.</p> <p>Parameters:</p> Name Type Description Default <code>pid</code> <code>int</code> <p>PID do processo existente.</p> required <code>forcar</code> <code>bool</code> <p>For\u00e7a o encerramento do processo.</p> <code>False</code> <code>tempo_espera</code> <code>int</code> <p>Tempo limite em segundos para a tentativa de             encerramento do processo.</p> <code>60</code> <p>Returns:</p> Type Description <code>bool</code> <p>Retorna booleano, <code>True</code> caso o processo seja encerrado             com sucesso, <code>False</code> caso o processo n\u00e3o seja             encerrado com sucesso</p> <p>Raises:</p> Type Description <code>ValueError</code> <p><code>caminho_campo</code> precisa ser do tipo dict.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; encerrar_app(\n...     pid=39440,\n...     forcar=True,\n...     tempo_espera=10,\n... )\nTrue\n</code></pre> Source code in <code>py_rpautom\\desktop_utils.py</code> <pre><code>def encerrar_app(\n    pid: int,\n    forcar: bool = False,\n    tempo_espera: int = 60,\n) -&gt; bool:\n    \"\"\"Encerra um processo do sistema de um objeto do tipo Application \\\n        sendo manipulado.\n\n    Parameters:\n        pid: PID do processo existente.\n        forcar: For\u00e7a o encerramento do processo.\n        tempo_espera: Tempo limite em segundos para a tentativa de \\\n            encerramento do processo.\n\n    Returns:\n        Retorna booleano, `True` caso o processo seja encerrado \\\n            com sucesso, `False` caso o processo n\u00e3o seja \\\n            encerrado com sucesso\n\n    Raises:\n        ValueError: `caminho_campo` precisa ser do tipo dict.\n        ...\n\n\n    Examples:\n        &gt;&gt;&gt; encerrar_app(\n        ...     pid=39440,\n        ...     forcar=True,\n        ...     tempo_espera=10,\n        ... )\n        True\n    \"\"\"\n\n    # importa app para o escopo da fun\u00e7\u00e3o\n    global APP\n\n    # conecta a aplica\u00e7\u00e3o correspondente ao PID informado\n    app_interno: Application = _conectar_app(\n        pid=pid,\n        tempo_espera=tempo_espera,\n        estilo_aplicacao=ESTILO_APLICACAO,\n    )\n\n    # encerra o aplicativo em execu\u00e7\u00e3o\n    app_interno.kill(soft=not forcar)\n\n    # retorna o objeto application com o processo encerrado\n    return True\n</code></pre>"},{"location":"guia_usuario/desktop_utils/#coletando-o-estado-de-foco-atual-da-janela","title":"Coletando o estado de foco atual da janela","text":"<p>As janelas de uma aplica\u00e7\u00e3o dentro de um sistema operacional tem estados de focos padr\u00f5es, com foco ou sem foco. Estes estados de foco podem ser capturados utilizando a fun\u00e7\u00e3o <code>esta_com_foco</code>, que retorna a situa\u00e7\u00e3o do foco da janela no momento de sua execu\u00e7\u00e3o.</p>"},{"location":"guia_usuario/desktop_utils/#funcao-esta_com_foco","title":"fun\u00e7\u00e3o esta_com_foco","text":"<p>Verifica se a janela de um objeto do tipo Application est\u00e1 com foco.</p> <p>Parameters:</p> Name Type Description Default <code>nome_janela</code> <code>str</code> <p>O nome de uma janela j\u00e1 manipul\u00e1vel.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Retorna booleano, <code>True</code> caso a janela estiver com foco,         <code>False</code> caso a janela n\u00e3o estiver com foco.</p> <p>Examples:</p>"},{"location":"guia_usuario/desktop_utils/#desktop_utils.esta_com_foco--validacao-sem-foco-na-janela-no-momento-da-execucao-do-comando","title":"Valida\u00e7\u00e3o sem foco na janela no momento da execu\u00e7\u00e3o do comando","text":"<pre><code>&gt;&gt;&gt; esta_com_foco(\n...     nome_janela='Untitled - Notepad',\n... )\nFalse\n</code></pre>"},{"location":"guia_usuario/desktop_utils/#desktop_utils.esta_com_foco--validacao-com-foco-na-janela-no-momento-da-execucao-do-comando","title":"Valida\u00e7\u00e3o com foco na janela no momento da execu\u00e7\u00e3o do comando","text":"<pre><code>&gt;&gt;&gt; esta_com_foco(\n...     nome_janela='Untitled - Notepad',\n... )\nTrue\n</code></pre> Source code in <code>py_rpautom\\desktop_utils.py</code> <pre><code>def esta_com_foco(nome_janela: str) -&gt; bool:\n    \"\"\"Verifica se a janela de um objeto do tipo Application est\u00e1 com foco.\n\n    Parameters:\n        nome_janela: O nome de uma janela j\u00e1 manipul\u00e1vel.\n\n    Returns:\n        Retorna booleano, `True` caso a janela estiver com foco, \\\n        `False` caso a janela n\u00e3o estiver com foco.\n\n    Raises:\n        ...\n\n    Examples:\n        #### Valida\u00e7\u00e3o sem foco na janela no momento da execu\u00e7\u00e3o do comando\n        &gt;&gt;&gt; esta_com_foco(\n        ...     nome_janela='Untitled - Notepad',\n        ... )\n        False\n\n        #### Valida\u00e7\u00e3o com foco na janela no momento da execu\u00e7\u00e3o do comando\n        &gt;&gt;&gt; esta_com_foco(\n        ...     nome_janela='Untitled - Notepad',\n        ... )\n        True\n    \"\"\"\n\n    # importa app para o escopo da fun\u00e7\u00e3o\n    global APP\n\n    # inicializa APP para uma vari\u00e1vel interna\n    app_interno = APP\n\n    # retorna a situacao atual de foco da janela\n    return app_interno.window(title=nome_janela).has_focus()\n</code></pre>"},{"location":"guia_usuario/desktop_utils/#coletando-o-estado-de-visibilidade-atual-de-uma-janela","title":"Coletando o estado de visibilidade atual de uma janela","text":"<p>As janelas de uma aplica\u00e7\u00e3o dentro de um sistema operacional tem estados de visibilidade padr\u00f5es, como vis\u00edvel ou n\u00e3o vis\u00edvel. Entende-se por vis\u00edvel, a situa\u00e7\u00e3o da janela onde est\u00e1 em estado 'maximizado' ou 'normal'. E n\u00e3o vis\u00edvel para 'minimizado'. Estes estados de visibilidade podem ser capturados utilizando a fun\u00e7\u00e3o <code>esta_visivel</code>, que retorna a situa\u00e7\u00e3o de visibilidade da janela no momento de sua execu\u00e7\u00e3o.</p>"},{"location":"guia_usuario/desktop_utils/#funcao-esta_visivel","title":"fun\u00e7\u00e3o esta_visivel","text":"<p>Verifica se a janela de um objeto do tipo Application est\u00e1 vis\u00edvel.</p> <p>Parameters:</p> Name Type Description Default <code>nome_janela</code> <code>dict</code> <p>Caminho da janela na estrutura da aplica\u00e7\u00e3o             sendo manipulada.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Retorna uma string, sendo um dos valores a seguir: 'visivel',             'n\u00e3o vis\u00edvel', e 'n\u00e3o identificado'.</p> <p>Examples:</p>"},{"location":"guia_usuario/desktop_utils/#desktop_utils.esta_visivel--validacao-com-a-janela-restaurada-no-momento-da-execucao-do-comando","title":"Valida\u00e7\u00e3o com a janela restaurada no momento da execu\u00e7\u00e3o do comando","text":"<pre><code>&gt;&gt;&gt; esta_visivel(\n...     nome_janela={\n...         'window': {\n...             'title': 'Untitled - Notepad',\n...         }\n...     }\n... )\n'visivel'\n</code></pre>"},{"location":"guia_usuario/desktop_utils/#desktop_utils.esta_visivel--validacao-com-a-janela-minimizada-no-momento-da-execucao-do-comando","title":"Valida\u00e7\u00e3o com a janela minimizada no momento da execu\u00e7\u00e3o do comando","text":"<pre><code>&gt;&gt;&gt; esta_visivel(\n...     nome_janela={\n...         'window': {\n...             'title': 'Untitled - Notepad',\n...         }\n...     }\n... )\n'n\u00e3o vis\u00edvel'\n</code></pre> Source code in <code>py_rpautom\\desktop_utils.py</code> <pre><code>def esta_visivel(nome_janela: dict) -&gt; str:\n    \"\"\"Verifica se a janela de um objeto do tipo Application est\u00e1 vis\u00edvel.\n\n    Parameters:\n        nome_janela: Caminho da janela na estrutura da aplica\u00e7\u00e3o \\\n            sendo manipulada.\n\n    Returns:\n        Retorna uma string, sendo um dos valores a seguir: 'visivel', \\\n            'n\u00e3o vis\u00edvel', e 'n\u00e3o identificado'.\n\n    Raises:\n        ...\n\n    Examples:\n        #### Valida\u00e7\u00e3o com a janela restaurada no momento da execu\u00e7\u00e3o do comando\n        &gt;&gt;&gt; esta_visivel(\n        ...     nome_janela={\n        ...         'window': {\n        ...             'title': 'Untitled - Notepad',\n        ...         }\n        ...     }\n        ... )\n        'visivel'\n\n        #### Valida\u00e7\u00e3o com a janela minimizada no momento da execu\u00e7\u00e3o do comando\n        &gt;&gt;&gt; esta_visivel(\n        ...     nome_janela={\n        ...         'window': {\n        ...             'title': 'Untitled - Notepad',\n        ...         }\n        ...     }\n        ... )\n        'n\u00e3o vis\u00edvel'\n    \"\"\"\n\n    # coleta a situa\u00e7\u00e3o atual da janela\n    situacao = coletar_situacao_janela(nome_janela)\n\n    # define vis\u00edvel para situa\u00e7\u00e3o 'maximizado' ou 'normal'\n    if situacao == 'maximizado' or situacao == 'normal':\n        situacao = 'visivel'\n    # define n\u00e3o vis\u00edvel para situa\u00e7\u00e3o 'minimizado'\n    elif situacao == 'minimizado':\n        situacao = 'n\u00e3o vis\u00edvel'\n    # Caso n\u00e3o encontre as situa\u00e7\u00f5es normal, ninimizado e maximizado\n    else:\n        # define um valor padr\u00e3o\n        situacao = 'n\u00e3o identificado'\n\n    # retorna a situa\u00e7\u00e3o da janela\n    return situacao\n</code></pre>"},{"location":"guia_usuario/desktop_utils/#fechando-uma-janela-de-uma-aplicacao","title":"Fechando uma janela de uma aplica\u00e7\u00e3o","text":"<p>Para fechar uma janela aberta de uma aplica\u00e7\u00e3o, utilize a fun\u00e7\u00e3o <code>fechar_janela</code>.</p>"},{"location":"guia_usuario/desktop_utils/#funcao-fechar_janela","title":"fun\u00e7\u00e3o fechar_janela","text":"<p>Encerra uma janela de um objeto do tipo Application sendo manipulado.</p> <p>Parameters:</p> Name Type Description Default <code>caminho_janela</code> <code>dict</code> <p>Caminho da janela na estrutura da aplica\u00e7\u00e3o             sendo manipulada.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Retorna booleano, <code>True</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p><code>caminho_janela</code> precisa ser do tipo dict.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fechar_janela(\n...     caminho_janela={\n...         'window': {\n...             'title': 'Untitled - Notepad',\n...         }\n...     }\n... )\nTrue\n</code></pre> Source code in <code>py_rpautom\\desktop_utils.py</code> <pre><code>def fechar_janela(caminho_janela: dict) -&gt; bool:\n    \"\"\"Encerra uma janela de um objeto do tipo Application sendo manipulado.\n\n    Parameters:\n        caminho_janela: Caminho da janela na estrutura da aplica\u00e7\u00e3o \\\n            sendo manipulada.\n\n    Returns:\n        Retorna booleano, `True`.\n\n    Raises:\n        ValueError: `caminho_janela` precisa ser do tipo dict.\n\n    Examples:\n        &gt;&gt;&gt; fechar_janela(\n        ...     caminho_janela={\n        ...         'window': {\n        ...             'title': 'Untitled - Notepad',\n        ...         }\n        ...     }\n        ... )\n        True\n    \"\"\"\n\n    # importa app para o escopo da fun\u00e7\u00e3o\n    global APP\n\n    if isinstance(caminho_janela, dict) is False:\n        raise ValueError('`caminho_janela` precisa ser do tipo dict.')\n\n    # inicializa APP para uma vari\u00e1vel interna\n    app_interno = _localizar_elemento(\n        caminho_campo=caminho_janela,\n    )\n    app_interno.exists()\n\n    # fecha a janela informada\n    app_interno.close()\n\n    # retorna verdadeiro confirmando a execu\u00e7\u00e3o da a\u00e7\u00e3o\n    return True\n</code></pre>"},{"location":"guia_usuario/desktop_utils/#iniciando-uma-aplicacao","title":"Iniciando uma aplica\u00e7\u00e3o","text":"<p>Para iniciar e abrir uma aplica\u00e7\u00e3o, utilize a fun\u00e7\u00e3o <code>iniciar_app</code> conforme descrito abaixo.</p>"},{"location":"guia_usuario/desktop_utils/#funcao-iniciar_app","title":"fun\u00e7\u00e3o iniciar_app","text":"<p>Inicia um processo do sistema de um objeto do tipo Application  sendo manipulado.</p> <p>Parameters:</p> Name Type Description Default <code>executavel</code> <code>str</code> <p>Caminho da aplica\u00e7\u00e3o a ser manipulada.</p> required <code>estilo_aplicacao</code> <code>str</code> <p>Estilo de aplica\u00e7\u00e3o a ser manipulado, sendo             'win32' e 'uia' os valores aceitos.</p> <code>'win32'</code> <code>esperar</code> <code>tuple</code> <p>Define, em uma tupla, a condi\u00e7\u00e3o esperada pela             aplica\u00e7\u00e3o, sendo o primeiro valor a condi\u00e7\u00e3o esperada nos             valores 'exists', 'visible', 'enabled', 'ready', ou 'active',             e o segundo valor o tempo limite de espera em segundos.</p> <code>()</code> <code>inverter</code> <code>bool</code> <p><code>True</code> Aguarda a inicializa\u00e7\u00e3o da aplica\u00e7\u00e3o             ficar na condi\u00e7\u00e3o informada, <code>False</code> aguarda a inicializa\u00e7\u00e3o             da aplica\u00e7\u00e3o ficar diferente da condi\u00e7\u00e3o informada.</p> <code>False</code> <code>ocioso</code> <code>bool</code> <p>Define se deve aguardar a inicializa\u00e7\u00e3o da             aplica\u00e7\u00e3o sair do ocioso. <code>True</code> para aguardar,             <code>False</code> para n\u00e3o aguardar.</p> <code>False</code> <p>Returns:</p> Type Description <code>int</code> <p>Retorna int, sendo o PID do processo manipulado.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iniciar_app(\n...     executavel= 'C:\\Program Files\\WindowsApps\\Microsoft.WindowsNotepad_11.2410.21.0_x64__8wekyb3d8bbwe\\Notepad\\Notepad.exe',\n...     estilo_aplicacao='uia',\n...     esperar=('ready', 10),\n...     ocioso=False,\n...     inverter=True,\n... )\n40944\n</code></pre> Source code in <code>py_rpautom\\desktop_utils.py</code> <pre><code>def iniciar_app(\n    executavel: str,\n    estilo_aplicacao: str = 'win32',\n    esperar: tuple = (),\n    inverter: bool = False,\n    ocioso: bool = False,\n) -&gt; int:\n    \"\"\"Inicia um processo do sistema de um objeto do tipo Application  sendo manipulado.\n\n    Parameters:\n        executavel: Caminho da aplica\u00e7\u00e3o a ser manipulada.\n        estilo_aplicacao: Estilo de aplica\u00e7\u00e3o a ser manipulado, sendo \\\n            'win32' e 'uia' os valores aceitos.\n        esperar: Define, em uma tupla, a condi\u00e7\u00e3o esperada pela \\\n            aplica\u00e7\u00e3o, sendo o primeiro valor a condi\u00e7\u00e3o esperada nos \\\n            valores 'exists', 'visible', 'enabled', 'ready', ou 'active', \\\n            e o segundo valor o tempo limite de espera em segundos.\n        inverter: `True` Aguarda a inicializa\u00e7\u00e3o da aplica\u00e7\u00e3o \\\n            ficar na condi\u00e7\u00e3o informada, `False` aguarda a inicializa\u00e7\u00e3o \\\n            da aplica\u00e7\u00e3o ficar diferente da condi\u00e7\u00e3o informada.\n        ocioso: Define se deve aguardar a inicializa\u00e7\u00e3o da \\\n            aplica\u00e7\u00e3o sair do ocioso. `True` para aguardar, \\\n            `False` para n\u00e3o aguardar.\n\n    Returns:\n        Retorna int, sendo o PID do processo manipulado.\n\n    Raises:\n        ...\n\n    Examples:\n        &gt;&gt;&gt; iniciar_app(\n        ...     executavel= 'C:\\\\Program Files\\\\WindowsApps\\\\Microsoft.WindowsNotepad_11.2410.21.0_x64__8wekyb3d8bbwe\\\\Notepad\\\\Notepad.exe',\n        ...     estilo_aplicacao='uia',\n        ...     esperar=('ready', 10),\n        ...     ocioso=False,\n        ...     inverter=True,\n        ... )\n        40944\n    \"\"\"\n\n    # define app como global\n    global APP\n    global ESTILO_APLICACAO\n\n    ESTILO_APLICACAO = estilo_aplicacao\n\n    # instancia o objeto application\n    APP = _aplicacao(estilo_aplicacao=ESTILO_APLICACAO)\n\n    # inicia o processo de execu\u00e7\u00e3o do aplicativo passado como par\u00e2metro\n    APP.start(\n        cmd_line=executavel,\n        wait_for_idle=ocioso,\n    )\n\n    esperar_por = tempo_espera = None\n    # verifica se foi passado algum par\u00e2metro para esperar, caso n\u00e3o:\n    if esperar == ():\n        # aguarda a inicializa\u00e7\u00e3o da aplica\u00e7\u00e3o ficar pronta em at\u00e9 10 segundos\n        esperar_por = 'ready'\n        tempo_espera = 10\n    else:\n        esperar_por, tempo_espera = esperar\n\n    if inverter is False:\n        # aguarda a inicializa\u00e7\u00e3o da aplica\u00e7\u00e3o ficar na condi\u00e7\u00e3o informada\n        APP.window().wait(\n            wait_for=esperar_por,\n            timeout=tempo_espera,\n            retry_interval=None,\n        )\n    else:\n        # aguarda a inicializa\u00e7\u00e3o da aplica\u00e7\u00e3o n\u00e3o ficar na condi\u00e7\u00e3o informada\n        APP.window().wait_not(\n            wait_for_not=esperar_por,\n            timeout=tempo_espera,\n            retry_interval=None,\n        )\n\n    # coleta o PID da aplica\u00e7\u00e3o instanciada\n    processo_app: int = APP.process\n\n    # retorna o PID coletado\n    return processo_app\n</code></pre>"},{"location":"guia_usuario/desktop_utils/#coletando-o-estado-de-existencia-atual-de-uma-janela","title":"Coletando o estado de exist\u00eancia atual de uma janela","text":"<p>Para verificar se uma janela de uma aplica\u00e7\u00e3o existe, utilize a fun\u00e7\u00e3o <code>janela_existente</code>.</p>"},{"location":"guia_usuario/desktop_utils/#funcao-janela_existente","title":"fun\u00e7\u00e3o janela_existente","text":"<p>Verifica se a janela de um objeto do tipo Application existe.</p> <p>Parameters:</p> Name Type Description Default <code>nome_janela</code> <p>O nome de uma janela j\u00e1 manipul\u00e1vel.</p> required <code>pid</code> <p>PID do processo existente.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Retorna booleano, <code>True</code> caso a janela da aplica\u00e7\u00e3o exista,             <code>False</code> caso a janela da aplica\u00e7\u00e3o n\u00e3o exista.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; janela_existente(\n...     pid=39440,\n...     nome_janela='Untitled - Notepad',\n... )\nTrue\n</code></pre> Source code in <code>py_rpautom\\desktop_utils.py</code> <pre><code>def janela_existente(pid, nome_janela) -&gt; bool:\n    \"\"\"Verifica se a janela de um objeto do tipo Application existe.\n\n    Parameters:\n        nome_janela: O nome de uma janela j\u00e1 manipul\u00e1vel.\n        pid: PID do processo existente.\n\n    Returns:\n        Retorna booleano, `True` caso a janela da aplica\u00e7\u00e3o exista, \\\n            `False` caso a janela da aplica\u00e7\u00e3o n\u00e3o exista.\n\n    Raises:\n        ...\n\n    Examples:\n        &gt;&gt;&gt; janela_existente(\n        ...     pid=39440,\n        ...     nome_janela='Untitled - Notepad',\n        ... )\n        True\n    \"\"\"\n\n    # coleta a situa\u00e7\u00e3o atual da janela\n    lista_janelas = retornar_janelas_disponiveis(pid)\n\n    # verifica se o nome da janela informada corresponde \u00e0 alguma janela na lista\n    for janela in lista_janelas:\n        # caso o nome da janela seja o mesmo da janela atual da lista\n        if janela == nome_janela:\n            # retorna True\n            return True\n\n    # retorna False caso nenhuma janela tenha correspondido\n    return False\n</code></pre>"},{"location":"guia_usuario/desktop_utils/#selecionando-um-caminho-em-uma-lista-de-diretorios","title":"Selecionando um caminho em uma lista de diret\u00f3rios","text":"<p>Para selecionar um caminho em uma lista hier\u00e1rquica de diret\u00f3rios, elemento do tipo treeview, utilize a fun\u00e7\u00e3o <code>localizar_diretorio_em_treeview</code>.</p> <p>Para informar o caminho do elemento, deve-se seguir a             estrutura de elementos conforme apresendado na sess\u00e3o             \"Estrutura de hierarquia de um elemento\".</p>"},{"location":"guia_usuario/desktop_utils/#funcao-localizar_diretorio_em_treeview","title":"fun\u00e7\u00e3o localizar_diretorio_em_treeview","text":"<p>Localiza um diret\u00f3rio, seguindo a \u00e1rvore de diret\u00f3rios informada,         dentro de um objeto TreeView do tipo Application.</p> <p>Parameters:</p> Name Type Description Default <code>caminho_janela</code> <code>dict</code> <p>Caminho da janela na estrutura da aplica\u00e7\u00e3o             sendo manipulada.</p> required <code>caminho_diretorio</code> <code>str</code> <p>Caminho da estrutura de diret\u00f3rios a ser localizada.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Retorna booleano, <code>True</code> caso a localiza\u00e7\u00e3o tenha sucesso,             <code>False</code> caso a localiza\u00e7\u00e3o n\u00e3o tenha sucesso.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p><code>caminho_janela</code> precisa ser do tipo dict.</p> <p>Examples:</p> <p>...</p> Source code in <code>py_rpautom\\desktop_utils.py</code> <pre><code>def localizar_diretorio_em_treeview(\n    caminho_janela: dict,\n    caminho_diretorio: str,\n) -&gt; bool:\n    \"\"\"Localiza um diret\u00f3rio, seguindo a \u00e1rvore de diret\u00f3rios informada, \\\n        dentro de um objeto TreeView do tipo Application.\n\n    Parameters:\n        caminho_janela: Caminho da janela na estrutura da aplica\u00e7\u00e3o \\\n            sendo manipulada.\n        caminho_diretorio: Caminho da estrutura de diret\u00f3rios a ser localizada.\n\n    Returns:\n        Retorna booleano, `True` caso a localiza\u00e7\u00e3o tenha sucesso, \\\n            `False` caso a localiza\u00e7\u00e3o n\u00e3o tenha sucesso.\n\n    Raises:\n        ValueError: `caminho_janela` precisa ser do tipo dict.\n\n    Examples:\n        ...\n    \"\"\"\n\n    try:\n        if isinstance(caminho_janela, dict) is False:\n            raise ValueError('`caminho_janela` precisa ser do tipo dict.')\n\n        # localiza e armazena o elemento conforme informado\n        app_interno = _localizar_elemento(caminho_janela)\n        app_interno.exists()\n\n        # seleciona o caminho informado na janela do tipo TreeView\n        app_interno.TreeView.get_item(caminho_diretorio).click()\n\n        # clica em Ok para confirmar\n        app_interno.OK.click()\n\n        # retorna verdadeiro caso processo seja feito com sucesso\n        return True\n    except:\n        return False\n</code></pre>"},{"location":"guia_usuario/desktop_utils/#localizando-uma-janela-ou-elemento-em-uma-janela","title":"Localizando uma janela ou elemento em uma janela","text":"<p>\u00c9 poss\u00edvel verificar se uma janela ou um elemento dentro de uma janela na estrutura de elementos da aplica\u00e7\u00e3o que est\u00e1 sendo manipulado existe atrav\u00e9s da fun\u00e7\u00e3o <code>localizar_elemento</code>.</p> <p>Para informar o caminho do elemento, deve-se seguir a             estrutura de elementos conforme apresendado na sess\u00e3o             \"Estrutura de hierarquia de um elemento\".</p>"},{"location":"guia_usuario/desktop_utils/#funcao-localizar_elemento","title":"fun\u00e7\u00e3o localizar_elemento","text":"<p>Retorna se o caminho de elementos informado existe no objeto do         tipo Application sendo manipulado.</p> <p>Parameters:</p> Name Type Description Default <code>caminho_campo</code> <code>dict</code> <p>Caminho do elemento na estrutura da aplica\u00e7\u00e3o             sendo manipulada.</p> required <code>estilo_aplicacao</code> <p>Estilo de aplica\u00e7\u00e3o a ser manipulado, sendo             'win32' e 'uia' os valores aceitos.</p> <code>'win32'</code> <p>Returns:</p> Type Description <code>bool</code> <p>Retorna booleano, <code>True</code> caso o caminho do elemento na aplica\u00e7\u00e3o             exista, <code>False</code> caso o caminho do elemento na aplica\u00e7\u00e3o             n\u00e3o exista.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p><code>caminho_campo</code> precisa ser do tipo dict.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; localizar_elemento(\n...     caminho_campo={\n...         'window': {\n...             'title': 'Untitled - Notepad',\n...             'child_window': {\n...                 'title': 'DesktopWindowXamlSource',\n...                 'best_match': 'Windows.UI.Composition.DesktopWindowContentBridge2',\n...                 'child_window': {\n...                     'best_match': 'Windows.UI.Input.InputSite.WindowClass2',\n...                 }\n...             }\n...         }\n...     },\n...     estilo_aplicacao='win32',\n... )\nTrue\n</code></pre> Source code in <code>py_rpautom\\desktop_utils.py</code> <pre><code>def localizar_elemento(\n    caminho_campo: dict,\n    estilo_aplicacao='win32',\n) -&gt; bool:\n    \"\"\"Retorna se o caminho de elementos informado existe no objeto do \\\n        tipo Application sendo manipulado.\n\n    Parameters:\n        caminho_campo: Caminho do elemento na estrutura da aplica\u00e7\u00e3o \\\n            sendo manipulada.\n        estilo_aplicacao: Estilo de aplica\u00e7\u00e3o a ser manipulado, sendo \\\n            'win32' e 'uia' os valores aceitos.\n\n    Returns:\n        Retorna booleano, `True` caso o caminho do elemento na aplica\u00e7\u00e3o \\\n            exista, `False` caso o caminho do elemento na aplica\u00e7\u00e3o \\\n            n\u00e3o exista.\n\n    Raises:\n        ValueError: `caminho_campo` precisa ser do tipo dict.\n\n    Examples:\n        &gt;&gt;&gt; localizar_elemento(\n        ...     caminho_campo={\n        ...         'window': {\n        ...             'title': 'Untitled - Notepad',\n        ...             'child_window': {\n        ...                 'title': 'DesktopWindowXamlSource',\n        ...                 'best_match': 'Windows.UI.Composition.DesktopWindowContentBridge2',\n        ...                 'child_window': {\n        ...                     'best_match': 'Windows.UI.Input.InputSite.WindowClass2',\n        ...                 }\n        ...             }\n        ...         }\n        ...     },\n        ...     estilo_aplicacao='win32',\n        ... )\n        True\n    \"\"\"\n\n    # importa app para o escopo da fun\u00e7\u00e3o\n    global APP\n\n    if isinstance(caminho_campo, dict) is False:\n        raise ValueError('`caminho_campo` precisa ser do tipo dict.')\n\n    # inicializa APP para uma vari\u00e1vel interna\n    app_interno = _localizar_elemento(\n        caminho_campo=caminho_campo,\n    )\n    app_interno.exists()\n\n    return app_interno.exists()\n</code></pre>"},{"location":"guia_usuario/desktop_utils/#maximizando-uma-janela","title":"Maximizando uma janela","text":"<p>As janelas de uma aplica\u00e7\u00e3o dentro de um sistema operacional tem estados padr\u00f5es, como estar maximizado. utilize a fun\u00e7\u00e3o <code>maximizar_janela</code> para, no momento de sua execu\u00e7\u00e3o, alterar uma janela para maximizado.</p> <p>Para informar o caminho do elemento, deve-se seguir a             estrutura de elementos conforme apresendado na sess\u00e3o             \"Estrutura de hierarquia de um elemento\".</p>"},{"location":"guia_usuario/desktop_utils/#funcao-maximizar_janela","title":"fun\u00e7\u00e3o maximizar_janela","text":"<p>Maximiza a janela de um objeto do tipo Application.</p> <p>Parameters:</p> Name Type Description Default <code>caminho_janela</code> <code>dict</code> <p>Caminho da janela na estrutura da aplica\u00e7\u00e3o             sendo manipulada.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Retorna booleano, <code>True</code> caso a a\u00e7\u00e3o de maximizar tenha sucesso,         <code>False</code> caso a a\u00e7\u00e3o de maximizar n\u00e3o tenha sucesso.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; maximizar_janela(\n...     caminho_janela={\n...         'window': {\n...             'title': 'Untitled - Notepad',\n...         }\n...     }\n... )\nTrue\n</code></pre> Source code in <code>py_rpautom\\desktop_utils.py</code> <pre><code>def maximizar_janela(caminho_janela: dict) -&gt; bool:\n    \"\"\"Maximiza a janela de um objeto do tipo Application.\n\n    Parameters:\n        caminho_janela: Caminho da janela na estrutura da aplica\u00e7\u00e3o \\\n            sendo manipulada.\n\n    Returns:\n        Retorna booleano, `True` caso a a\u00e7\u00e3o de maximizar tenha sucesso, \\\n        `False` caso a a\u00e7\u00e3o de maximizar n\u00e3o tenha sucesso.\n\n    Raises:\n        `caminho_janela` precisa ser do tipo dict.\n\n    Examples:\n        &gt;&gt;&gt; maximizar_janela(\n        ...     caminho_janela={\n        ...         'window': {\n        ...             'title': 'Untitled - Notepad',\n        ...         }\n        ...     }\n        ... )\n        True\n    \"\"\"\n\n    # importa app para o escopo da fun\u00e7\u00e3o\n    global APP\n\n    if isinstance(caminho_janela, dict) is False:\n        raise ValueError('`caminho_janela` precisa ser do tipo dict.')\n\n    try:\n        # localiza o elemento at\u00e9 o final da \u00e1rvore de parantesco do app\n        app_interno = _localizar_elemento(caminho_janela)\n        app_interno.exists()\n\n        # maximiza a janela informada\n        app_interno.maximize()\n\n        # retorna verdadeiro confirmando a execu\u00e7\u00e3o da a\u00e7\u00e3o\n        return True\n    except:\n        return False\n</code></pre>"},{"location":"guia_usuario/desktop_utils/#minimizando-uma-janela","title":"Minimizando uma janela","text":"<p>As janelas de uma aplica\u00e7\u00e3o dentro de um sistema operacional tem estados padr\u00f5es, como estar minimizado. utilize a fun\u00e7\u00e3o <code>minimizar_janela</code> para, no momento de sua execu\u00e7\u00e3o, alterar uma janela para minimizado.</p> <p>Para informar o caminho do elemento, deve-se seguir a             estrutura de elementos conforme apresendado na sess\u00e3o             \"Estrutura de hierarquia de um elemento\".</p>"},{"location":"guia_usuario/desktop_utils/#funcao-minimizar_janela","title":"fun\u00e7\u00e3o minimizar_janela","text":"<p>Miniminiza a janela de um objeto do tipo Application.</p> <p>Parameters:</p> Name Type Description Default <code>caminho_janela</code> <code>dict</code> <p>Caminho da janela na estrutura da aplica\u00e7\u00e3o             sendo manipulada.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Retorna booleano, <code>True</code> caso a a\u00e7\u00e3o de miniminizar tenha sucesso,         <code>False</code> caso a a\u00e7\u00e3o de miniminizar n\u00e3o tenha sucesso.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; minimizar_janela(\n...     caminho_janela={\n...         'window': {\n...             'title': 'Untitled - Notepad',\n...         }\n...     }\n... )\nTrue\n</code></pre> Source code in <code>py_rpautom\\desktop_utils.py</code> <pre><code>def minimizar_janela(caminho_janela: dict) -&gt; bool:\n    \"\"\"Miniminiza a janela de um objeto do tipo Application.\n\n    Parameters:\n        caminho_janela: Caminho da janela na estrutura da aplica\u00e7\u00e3o \\\n            sendo manipulada.\n\n    Returns:\n        Retorna booleano, `True` caso a a\u00e7\u00e3o de miniminizar tenha sucesso, \\\n        `False` caso a a\u00e7\u00e3o de miniminizar n\u00e3o tenha sucesso.\n\n    Raises:\n        `caminho_janela` precisa ser do tipo dict.\n\n    Examples:\n        &gt;&gt;&gt; minimizar_janela(\n        ...     caminho_janela={\n        ...         'window': {\n        ...             'title': 'Untitled - Notepad',\n        ...         }\n        ...     }\n        ... )\n        True\n    \"\"\"\n\n    # importa app para o escopo da fun\u00e7\u00e3o\n    global APP\n\n    if isinstance(caminho_janela, dict) is False:\n        raise ValueError('`caminho_janela` precisa ser do tipo dict.')\n\n    try:\n        # localiza o elemento at\u00e9 o final da \u00e1rvore de parantesco do app\n        app_interno = _localizar_elemento(caminho_janela)\n        app_interno.exists()\n\n        # miniminiza a janela informada\n        app_interno.minimize()\n\n        # retorna verdadeiro confirmando a execu\u00e7\u00e3o da a\u00e7\u00e3o\n        return True\n    except:\n        return False\n</code></pre>"},{"location":"guia_usuario/desktop_utils/#movendo-o-mouse","title":"Movendo o mouse","text":"<p>H\u00e1 um recurso para movimenta\u00e7\u00e3o do mouse at\u00e9 um ponto espec\u00edfico da tela, mediante coordenadas de eixo X e Y. As coordenadas precisam ser informadas em pixels e representam o posicionamento de pixels da tela. Para isso, utilize a fun\u00e7\u00e3o <code>mover_mouse</code>.</p>"},{"location":"guia_usuario/desktop_utils/#funcao-mover_mouse","title":"fun\u00e7\u00e3o mover_mouse","text":"<p>Move o mouse para o ponto das coordenadas X e Y informadas.</p> <p>Parameters:</p> Name Type Description Default <code>eixo_x</code> <code>int</code> <p>valor int para a posi\u00e7\u00e3o de coordenada X.</p> required <code>eixo_y</code> <code>int</code> <p>valor int para a posi\u00e7\u00e3o de coordenada Y.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Retorna booleano, <code>True</code> caso tenha sucesso ao mover o mouse,         <code>False</code> caso n\u00e3o tenha sucesso ao mover o mouse.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Coordenadas precisam ser do tipo inteiro .</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mover_mouse(eixo_x=961, eixo_y=562,)\nTrue\n</code></pre> Source code in <code>py_rpautom\\desktop_utils.py</code> <pre><code>def mover_mouse(eixo_x: int, eixo_y: int) -&gt; bool:\n    \"\"\"Move o mouse para o ponto das coordenadas X e Y informadas.\n\n    Parameters:\n        eixo_x: valor int para a posi\u00e7\u00e3o de coordenada X.\n        eixo_y: valor int para a posi\u00e7\u00e3o de coordenada Y.\n\n    Returns:\n        Retorna booleano, `True` caso tenha sucesso ao mover o mouse, \\\n        `False` caso n\u00e3o tenha sucesso ao mover o mouse.\n\n    Raises:\n        ValueError: Coordenadas precisam ser do tipo inteiro .\n\n    Examples:\n        &gt;&gt;&gt; mover_mouse(eixo_x=961, eixo_y=562,)\n        True\n    \"\"\"\n\n    # importa recursos do m\u00f3dulo mouse\n    from pywinauto.mouse import move\n\n    if (not isinstance(eixo_x, int)) or (not isinstance(eixo_y, int)):\n        raise ValueError('Coordenadas precisam ser do tipo inteiro .')\n\n    try:\n        move(coords=(eixo_x, eixo_y))\n\n        return True\n    except:\n        return False\n</code></pre>"},{"location":"guia_usuario/desktop_utils/#restaurando-uma-janela","title":"Restaurando uma janela","text":"<p>As janelas de uma aplica\u00e7\u00e3o dentro de um sistema operacional tem estados padr\u00f5es, como estar restaurado. utilize a fun\u00e7\u00e3o <code>restaurar_janela</code> para, no momento de sua execu\u00e7\u00e3o, alterar uma janela para restaurado.</p> <p>Para informar o caminho do elemento, deve-se seguir a             estrutura de elementos conforme apresendado na sess\u00e3o             \"Estrutura de hierarquia de um elemento\".</p>"},{"location":"guia_usuario/desktop_utils/#funcao-restaurar_janela","title":"fun\u00e7\u00e3o restaurar_janela","text":"<p>Restaura a janela de um objeto do tipo Application.</p> <p>Parameters:</p> Name Type Description Default <code>caminho_janela</code> <code>dict</code> <p>Caminho da janela na estrutura da aplica\u00e7\u00e3o             sendo manipulada.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Retorna booleano, <code>True</code> caso a a\u00e7\u00e3o de restaurar tenha sucesso,         <code>False</code> caso a a\u00e7\u00e3o de restaurar n\u00e3o tenha sucesso.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; restaurar_janela(\n...     caminho_janela={\n...         'window': {\n...             'title': 'Untitled - Notepad',\n...         }\n...     }\n... )\nTrue\n</code></pre> Source code in <code>py_rpautom\\desktop_utils.py</code> <pre><code>def restaurar_janela(caminho_janela: dict) -&gt; bool:\n    \"\"\"Restaura a janela de um objeto do tipo Application.\n\n    Parameters:\n        caminho_janela: Caminho da janela na estrutura da aplica\u00e7\u00e3o \\\n            sendo manipulada.\n\n    Returns:\n        Retorna booleano, `True` caso a a\u00e7\u00e3o de restaurar tenha sucesso, \\\n        `False` caso a a\u00e7\u00e3o de restaurar n\u00e3o tenha sucesso.\n\n    Raises:\n        `caminho_janela` precisa ser do tipo dict.\n\n    Examples:\n        &gt;&gt;&gt; restaurar_janela(\n        ...     caminho_janela={\n        ...         'window': {\n        ...             'title': 'Untitled - Notepad',\n        ...         }\n        ...     }\n        ... )\n        True\n    \"\"\"\n\n    # importa app para o escopo da fun\u00e7\u00e3o\n    global APP\n\n    if isinstance(caminho_janela, dict) is False:\n        raise ValueError('`caminho_janela` precisa ser do tipo dict.')\n\n    try:\n        # localiza o elemento at\u00e9 o final da \u00e1rvore de parantesco do app\n        app_interno = _localizar_elemento(caminho_janela)\n        app_interno.exists()\n\n        # restaura a janela informada\n        app_interno.restore()\n\n        # retorna verdadeiro confirmando a execu\u00e7\u00e3o da a\u00e7\u00e3o\n        return True\n    except:\n        return True\n</code></pre>"},{"location":"guia_usuario/desktop_utils/#verificando-janelas-disponiveis","title":"Verificando janelas dispon\u00edveis","text":"<p>Um recurso muito comum \u00e9 a verifica\u00e7\u00e3o das janelas existentes de uma aplica\u00e7\u00e3o em execu\u00e7\u00e3o. Para coletar todos os nomes de janelas dispon\u00edveis de uma aplica\u00e7\u00e3o em execu\u00e7\u00e3o e que est\u00e1 sendo manipulada, utilize a fun\u00e7\u00e3o abaixo, que retornar\u00e1, em string, os nomes coletados no momento de sua execu\u00e7\u00e3o.</p>"},{"location":"guia_usuario/desktop_utils/#funcao-retornar_janelas_disponiveis","title":"fun\u00e7\u00e3o retornar_janelas_disponiveis","text":"<p>Retorna as janelas dispon\u00edveis em um objeto do tipo         Application manipul\u00e1vel.</p> <p>Parameters:</p> Name Type Description Default <code>pid</code> <code>int</code> <p>PID do processo existente.</p> required <code>estilo_aplicacao</code> <p>Estilo de aplica\u00e7\u00e3o a ser manipulado, sendo             'win32' e 'uia' os valores aceitos.</p> <code>'win32'</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Retorna uma lista de strings, sendo o valor capturado do PID             informado.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; retornar_janelas_disponiveis(\n...     pid=24728,\n...     estilo_aplicacao='uia'\n... )\n</code></pre> Source code in <code>py_rpautom\\desktop_utils.py</code> <pre><code>def retornar_janelas_disponiveis(\n    pid: int,\n    estilo_aplicacao='win32',\n) -&gt; list[str]:\n    \"\"\"Retorna as janelas dispon\u00edveis em um objeto do tipo \\\n        Application manipul\u00e1vel.\n\n    Parameters:\n        pid: PID do processo existente.\n        estilo_aplicacao: Estilo de aplica\u00e7\u00e3o a ser manipulado, sendo \\\n            'win32' e 'uia' os valores aceitos.\n\n    Returns:\n        Retorna uma lista de strings, sendo o valor capturado do PID \\\n            informado.\n\n    Raises:\n        ...\n\n    Examples:\n        &gt;&gt;&gt; retornar_janelas_disponiveis(\n        ...     pid=24728,\n        ...     estilo_aplicacao='uia'\n        ... )\n    \"\"\"\n\n    # importa app para o escopo da fun\u00e7\u00e3o\n    global APP\n    global ESTILO_APLICACAO\n\n    ESTILO_APLICACAO = estilo_aplicacao\n\n    # instancia o objeto application\n    APP = _aplicacao(estilo_aplicacao=ESTILO_APLICACAO)\n\n    # conecta a aplica\u00e7\u00e3o correspondente ao PID informado\n    tempo_espera = 60\n    app_interno: Application = _conectar_app(\n        pid=pid,\n        tempo_espera=tempo_espera,\n        estilo_aplicacao=ESTILO_APLICACAO,\n    )\n\n    # coleta as janelas dispon\u00edveis\n    lista_janelas = app_interno.windows()\n\n    # instancia uma lista vazia\n    lista_janelas_str = []\n    # para cada janela na lista de janelas\n    for janela in lista_janelas:\n        # coleta e salva o nome da janela\n        lista_janelas_str.append(janela.texts()[0])\n\n    # retorna uma lista das janelas coletadas\n    return lista_janelas_str\n</code></pre> <p>Escolha o estilo da aplica\u00e7\u00e3o, Win32 ou UIA, de acordo com a arquitetura da aplica\u00e7\u00e3o que se quer manipular. Aplica\u00e7\u00f5es Win32 s\u00e3o aplica\u00e7\u00f5es no estilo cl\u00e1ssico do Windows, j\u00e1 aplica\u00e7\u00f5es UIA s\u00e3o aplica\u00e7\u00f5es modernas, em sua maioria disponibilizadas a partir da loja do Windows. Recomendamos que, em caso de d\u00favidas, teste as possibilidades e escolha o que melhor se adequa ao momento.</p>"},{"location":"guia_usuario/desktop_utils/#selecionando-uma-aba-disponivel","title":"Selecionando uma aba dispon\u00edvel","text":"<p>Para em um elemento de conjunto de abas, elemento do tipo tab control, selecionar alguma op\u00e7\u00e3o das op\u00e7\u00f5es de abas dispon\u00edveis, utilize a fun\u00e7\u00e3o abaixo, que retornar\u00e1, em booleano, se a aba foi selecionada no momento de sua execu\u00e7\u00e3o. \u00c9 poss\u00edvel selecionar a aba informando o n\u00famero correspondente da aba, ou seu nome, atrav\u00e9s do par\u00e2metro <code>item</code>.</p> <p>Para informar o caminho do elemento, deve-se seguir a             estrutura de elementos conforme apresendado na sess\u00e3o             \"Estrutura de hierarquia de um elemento\".</p>"},{"location":"guia_usuario/desktop_utils/#funcao-selecionar_aba","title":"fun\u00e7\u00e3o selecionar_aba","text":"<p>Seleciona uma aba em um conjunto de abas de um objeto do tipo         Application manipul\u00e1vel.</p> <p>Parameters:</p> Name Type Description Default <code>caminho_campo</code> <code>dict</code> <p>Caminho do elemento na estrutura da aplica\u00e7\u00e3o             sendo manipulada.</p> required <code>item</code> <code>Union[str, int]</code> <p>Valor em int ou em str da aba a ser selecionada.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Retorna booleano, <code>True</code> caso a aba seja selecionada com sucesso,         <code>False</code> caso a aba n\u00e3o seja selecionada com sucesso.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p><code>caminho_campo</code> precisa ser do tipo dict.</p> <code>ValueError</code> <p><code>item</code> precisa ser do tipo int ou str.</p> <p>Examples:</p> <p>...</p> Source code in <code>py_rpautom\\desktop_utils.py</code> <pre><code>def selecionar_aba(caminho_campo: dict, item: Union[str, int]) -&gt; bool:\n    \"\"\"Seleciona uma aba em um conjunto de abas de um objeto do tipo \\\n        Application manipul\u00e1vel.\n\n    Parameters:\n        caminho_campo: Caminho do elemento na estrutura da aplica\u00e7\u00e3o \\\n            sendo manipulada.\n        item: Valor em int ou em str da aba a ser selecionada.\n\n    Returns:\n        Retorna booleano, `True` caso a aba seja selecionada com sucesso, \\\n        `False` caso a aba n\u00e3o seja selecionada com sucesso.\n\n    Raises:\n        ValueError: `caminho_campo` precisa ser do tipo dict.\n        ValueError: `item` precisa ser do tipo int ou str.\n        ...\n\n    Examples:\n        ...\n    \"\"\"\n\n    from pywinauto.controls.common_controls import TabControlWrapper\n\n    # define est\u00e1tico como falso para trabalhar com elemento din\u00e2mico\n    if isinstance(caminho_campo, dict) is False:\n        raise ValueError('`caminho_campo` precisa ser do tipo dict.')\n\n    if isinstance(item, str) is False and isinstance(item, int) is False:\n        raise ValueError('`item` precisa ser do tipo int ou str.')\n\n    # localiza o elemento at\u00e9 o final da \u00e1rvore de parantesco do app\n    app_interno = _localizar_elemento(caminho_campo)\n    app_interno.exists()\n\n    try:\n        # seleciona o item informado\n        app_interno = TabControlWrapper(app_interno)\n        app_interno.select(item).click_input()\n\n        return True\n    except:\n        return False\n</code></pre>"},{"location":"guia_usuario/desktop_utils/#selecionando-um-valor-em-um-campo-de-listas","title":"Selecionando um valor em um campo de listas","text":"<p>Para em um campo de listas, elemento do tipo listbox, selecionar alguma op\u00e7\u00e3o das op\u00e7\u00f5es da listagem dispon\u00edvel, utilize a fun\u00e7\u00e3o abaixo, que retornar\u00e1, em booleano, se a op\u00e7\u00e3o foi selecionada no momento de sua execu\u00e7\u00e3o.</p> <p>Para informar o caminho do elemento, deve-se seguir a             estrutura de elementos conforme apresendado na sess\u00e3o             \"Estrutura de hierarquia de um elemento\".</p>"},{"location":"guia_usuario/desktop_utils/#funcao-selecionar_em_campo_lista","title":"fun\u00e7\u00e3o selecionar_em_campo_lista","text":"<p>Seleciona um dado em um elemento de lista em um objeto do         tipo Application.</p> <p>Parameters:</p> Name Type Description Default <code>caminho_campo</code> <code>dict</code> <p>Caminho do elemento na estrutura da aplica\u00e7\u00e3o             sendo manipulada.</p> required <code>item</code> <code>int</code> <p>Valor em int da op\u00e7\u00e3o no campo de sele\u00e7\u00e3o             a ser selecionada.</p> required <code>selecionar</code> <code>bool</code> <p>Ativa sele\u00e7\u00e3o f\u00edsica direto no elemento informado.</p> <code>True</code> <code>performar</code> <code>bool</code> <p>Ativa clique f\u00edsico direto no elemento informado.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>Retorna booleano, <code>True</code> caso a op\u00e7\u00e3o no campo de sele\u00e7\u00e3o seja             selecionada com sucesso, <code>False</code> caso a op\u00e7\u00e3o no campo de             sele\u00e7\u00e3o n\u00e3o seja selecionada com sucesso.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p><code>caminho_campo</code> precisa ser do tipo dict.</p> <code>ValueError</code> <p><code>item</code> precisa ser do tipo int.</p> <code>ValueError</code> <p><code>selecionar</code> precisa ser do tipo bool.</p> <code>ValueError</code> <p><code>performar</code> precisa ser do tipo bool.</p> <p>Examples:</p> <p>...</p> Source code in <code>py_rpautom\\desktop_utils.py</code> <pre><code>def selecionar_em_campo_lista(\n    caminho_campo: dict,\n    item: int,\n    selecionar: bool = True,\n    performar: bool = False,\n) -&gt; bool:\n    \"\"\"Seleciona um dado em um elemento de lista em um objeto do \\\n        tipo Application.\n\n    Parameters:\n        caminho_campo: Caminho do elemento na estrutura da aplica\u00e7\u00e3o \\\n            sendo manipulada.\n        item: Valor em int da op\u00e7\u00e3o no campo de sele\u00e7\u00e3o \\\n            a ser selecionada.\n        selecionar: Ativa sele\u00e7\u00e3o f\u00edsica direto no elemento informado.\n        performar: Ativa clique f\u00edsico direto no elemento informado.\n\n    Returns:\n        Retorna booleano, `True` caso a op\u00e7\u00e3o no campo de sele\u00e7\u00e3o seja \\\n            selecionada com sucesso, `False` caso a op\u00e7\u00e3o no campo de \\\n            sele\u00e7\u00e3o n\u00e3o seja selecionada com sucesso.\n\n    Raises:\n        ValueError: `caminho_campo` precisa ser do tipo dict.\n        ValueError: `item` precisa ser do tipo int.\n        ValueError: `selecionar` precisa ser do tipo bool.\n        ValueError: `performar` precisa ser do tipo bool.\n\n    Examples:\n        ...\n    \"\"\"\n\n    if isinstance(caminho_campo, dict) is False:\n        raise ValueError('`caminho_campo` precisa ser do tipo dict.')\n\n    if isinstance(item, int) is False:\n        raise ValueError('`item` precisa ser do tipo int.')\n\n    if isinstance(selecionar, bool) is False:\n        raise ValueError('`selecionar` precisa ser do tipo bool.')\n\n    if isinstance(performar, bool) is False:\n        raise ValueError('`performar` precisa ser do tipo bool.')\n\n    # localiza o elemento at\u00e9 o final da \u00e1rvore de parantesco do app\n    app_interno = _localizar_elemento(caminho_campo)\n\n    try:\n        # seleciona o item informado\n        if performar is True:\n            app_interno.select(item=item, select=selecionar).click_input()\n        else:\n            app_interno.select(item=item, select=selecionar)\n\n        return True\n    except:\n        return False\n</code></pre>"},{"location":"guia_usuario/desktop_utils/#selecionando-um-valor-em-um-campo-de-selecao","title":"Selecionando um valor em um campo de sele\u00e7\u00e3o","text":"<p>Para em um campo de sele\u00e7\u00e3o, elemento do tipo combobox, selecionar alguma op\u00e7\u00e3o das op\u00e7\u00f5es dispon\u00edveis, utilize a fun\u00e7\u00e3o abaixo, que retornar\u00e1, em string, o valor do campo informado alterado no momento de sua execu\u00e7\u00e3o.</p> <p>Para informar o caminho do elemento, deve-se seguir a             estrutura de elementos conforme apresendado na sess\u00e3o             \"Estrutura de hierarquia de um elemento\".</p>"},{"location":"guia_usuario/desktop_utils/#funcao-selecionar_em_campo_selecao","title":"fun\u00e7\u00e3o selecionar_em_campo_selecao","text":"<p>Seleciona uma op\u00e7\u00e3o em um elemento de sele\u00e7\u00e3o em um objeto do         tipo Application.</p> <p>Parameters:</p> Name Type Description Default <code>caminho_campo</code> <code>dict</code> <p>Caminho do elemento na estrutura da aplica\u00e7\u00e3o             sendo manipulada.</p> required <code>item</code> <code>str</code> <p>Valor em str da op\u00e7\u00e3o no campo de sele\u00e7\u00e3o             a ser selecionada.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Retorna str, sendo o valor capturado do elemento informado ap\u00f3s             a op\u00e7\u00e3o selecionada.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p><code>caminho_campo</code> precisa ser do tipo dict.</p> <code>ValueError</code> <p><code>item</code> precisa ser do tipo int.</p> <code>ValueError</code> <p><code>selecionar</code> precisa ser do tipo bool.</p> <code>ValueError</code> <p><code>performar</code> precisa ser do tipo bool.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; selecionar_em_campo_selecao(\n...     caminho_campo={\n...         'window': {\n...             'title': 'Character Map',\n...             'child_window': {\n...                 'title': 'Font :',\n...                 'control_type': 'ComboBox',\n...                 'auto_id': '105',\n...             }\n...         }\n...     },\n...     item='Arial'\n... )\n'Arial'\n</code></pre> Source code in <code>py_rpautom\\desktop_utils.py</code> <pre><code>def selecionar_em_campo_selecao(caminho_campo: dict, item: str) -&gt; str:\n    \"\"\"Seleciona uma op\u00e7\u00e3o em um elemento de sele\u00e7\u00e3o em um objeto do \\\n        tipo Application.\n\n    Parameters:\n        caminho_campo: Caminho do elemento na estrutura da aplica\u00e7\u00e3o \\\n            sendo manipulada.\n        item: Valor em str da op\u00e7\u00e3o no campo de sele\u00e7\u00e3o \\\n            a ser selecionada.\n\n    Returns:\n        Retorna str, sendo o valor capturado do elemento informado ap\u00f3s \\\n            a op\u00e7\u00e3o selecionada.\n\n    Raises:\n        ValueError: `caminho_campo` precisa ser do tipo dict.\n        ValueError: `item` precisa ser do tipo int.\n        ValueError: `selecionar` precisa ser do tipo bool.\n        ValueError: `performar` precisa ser do tipo bool.\n\n    Examples:\n        &gt;&gt;&gt; selecionar_em_campo_selecao(\n        ...     caminho_campo={\n        ...         'window': {\n        ...             'title': 'Character Map',\n        ...             'child_window': {\n        ...                 'title': 'Font :',\n        ...                 'control_type': 'ComboBox',\n        ...                 'auto_id': '105',\n        ...             }\n        ...         }\n        ...     },\n        ...     item='Arial'\n        ... )\n        'Arial'\n    \"\"\"\n\n    # define est\u00e1tico como falso para trabalhar com elemento din\u00e2mico\n    if isinstance(caminho_campo, dict) is False:\n        raise ValueError('`caminho_campo` precisa ser do tipo dict.')\n\n    # localiza o elemento at\u00e9 o final da \u00e1rvore de parantesco do app\n    app_interno = _localizar_elemento(caminho_campo)\n    app_interno.exists()\n\n    # seleciona o item informado\n    app_interno.select(item).click_input()\n\n    # captura o texto do campo localizado\n    valor_capturado = coletar_dado_selecionado(caminho_campo)\n\n    # retorna o valor capturado\n    return valor_capturado\n</code></pre>"},{"location":"guia_usuario/desktop_utils/#selecionando-um-item-de-menu","title":"Selecionando um item de menu","text":"<p>Para em menu, elemento do tipo MenuBar, selecionar alguma op\u00e7\u00e3o dos itens de menu dispon\u00edveis, utilize a fun\u00e7\u00e3o abaixo, que retornar\u00e1, em booleano, se o item de menu foi selecionado no momento de sua execu\u00e7\u00e3o.</p> <p>Para informar o caminho do elemento, deve-se seguir a             estrutura de elementos conforme apresendado na sess\u00e3o             \"Estrutura de hierarquia de um elemento\".</p>"},{"location":"guia_usuario/desktop_utils/#funcao-selecionar_menu","title":"fun\u00e7\u00e3o selecionar_menu","text":"<p>Seleciona um item de menu conforme o caminho informado em um objeto         do tipo Application.</p> <p>Parameters:</p> Name Type Description Default <code>caminho_janela</code> <code>dict</code> <p>Caminho da janela na estrutura da aplica\u00e7\u00e3o             sendo manipulada.</p> required <code>caminho_menu</code> <code>str</code> <p>Caminho do menu na estrutura da aplica\u00e7\u00e3o             sendo manipulada. Deve ser informado no formato             'Menu1-&gt;Menu2-&gt;Menu3'.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Retorna booleano, <code>True</code> caso a a\u00e7\u00e3o de selecionar o menu             tenha sucesso, <code>False</code> caso a a\u00e7\u00e3o de selecionar o menu             n\u00e3o tenha sucesso.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p><code>caminho_campo</code> precisa ser do tipo dict.</p> <code>ValueError</code> <p><code>item</code> precisa ser do tipo int.</p> <code>ValueError</code> <p><code>selecionar</code> precisa ser do tipo bool.</p> <code>ValueError</code> <p><code>performar</code> precisa ser do tipo bool.</p> <p>Examples:</p> <p>...</p> Source code in <code>py_rpautom\\desktop_utils.py</code> <pre><code>def selecionar_menu(caminho_janela: dict, caminho_menu: str) -&gt; bool:\n    \"\"\"Seleciona um item de menu conforme o caminho informado em um objeto \\\n        do tipo Application.\n\n    Parameters:\n        caminho_janela: Caminho da janela na estrutura da aplica\u00e7\u00e3o \\\n            sendo manipulada.\n        caminho_menu: Caminho do menu na estrutura da aplica\u00e7\u00e3o \\\n            sendo manipulada. Deve ser informado no formato \\\n            'Menu1-&gt;Menu2-&gt;Menu3'.\n\n    Returns:\n        Retorna booleano, `True` caso a a\u00e7\u00e3o de selecionar o menu \\\n            tenha sucesso, `False` caso a a\u00e7\u00e3o de selecionar o menu \\\n            n\u00e3o tenha sucesso.\n\n    Raises:\n        `caminho_janela` precisa ser do tipo dict.\n\n    Raises:\n        ValueError: `caminho_campo` precisa ser do tipo dict.\n        ValueError: `item` precisa ser do tipo int.\n        ValueError: `selecionar` precisa ser do tipo bool.\n        ValueError: `performar` precisa ser do tipo bool.\n\n    Examples:\n        ...\n    \"\"\"\n\n    # importa app para o escopo da fun\u00e7\u00e3o\n    if isinstance(caminho_janela, dict) is False:\n        raise ValueError('`caminho_janela` precisa ser do tipo dict.')\n\n    try:\n        # localiza o elemento at\u00e9 o final da \u00e1rvore de parantesco do app\n        app_interno = _localizar_elemento(caminho_janela)\n        app_interno.exists()\n\n        # percorre e clica no menu informado\n        app_interno.menu_select(caminho_menu)\n\n        # retorna verdadeiro confirmando a execu\u00e7\u00e3o da a\u00e7\u00e3o\n        return True\n    except:\n        return False\n</code></pre>"},{"location":"guia_usuario/desktop_utils/#simulando-clique-do-mouse","title":"Simulando clique do mouse","text":"<p>H\u00e1 um recurso para disparar eventos de clique do mouse em um ponto espec\u00edfico da tela, mediante coordenadas de eixo X e Y. As coordenadas precisam ser informadas em pixels e representam o posicionamento de pixels da tela. Para isso, utilize a fun\u00e7\u00e3o <code>simular_clique</code>.</p>"},{"location":"guia_usuario/desktop_utils/#funcao-simular_clique","title":"fun\u00e7\u00e3o simular_clique","text":"<p>Simula clique f\u00edsico do mouse conforme coordenadas X e Y informadas.</p> <p>Parameters:</p> Name Type Description Default <code>botao</code> <code>str</code> <p>valor str para o lado do bot\u00e3o a ser simulado.             Aceita valores 'ESQUERDO' e 'DIREITO'.</p> required <code>eixo_x</code> <code>int</code> <p>valor int para a posi\u00e7\u00e3o de coordenada X.</p> required <code>eixo_y</code> <code>int</code> <p>valor int para a posi\u00e7\u00e3o de coordenada Y.</p> required <code>tipo_clique</code> <code>str</code> <p>valor str para o tipo de clique a ser simulado.             Aceita valores 'UNICO' e 'DUPLO'.</p> <code>'unico'</code> <p>Returns:</p> Type Description <code>bool</code> <p>Retorna booleano, <code>True</code> caso tenha sucesso ao simular o clique,         <code>False</code> caso n\u00e3o tenha sucesso ao simular o clique.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Informe um bot\u00e3o v\u00e1lido: esquerdo, direito.</p> <code>ValueError</code> <p>Tipo de clique inv\u00e1lido, escolha entre \u00fanico e duplo.</p> <code>ValueError</code> <p>Coordenadas precisam ser do tipo inteiro .</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; simular_clique(\n...     botao='ESQUERDO',\n...     eixo_x=valor_eixo_x,\n...     eixo_y=valor_eixo_y,\n...     tipo_clique='UNICO',\n... )\nTrue\n</code></pre> Source code in <code>py_rpautom\\desktop_utils.py</code> <pre><code>def simular_clique(\n    botao: str,\n    eixo_x: int,\n    eixo_y: int,\n    tipo_clique: str = 'unico',\n) -&gt; bool:\n    \"\"\"Simula clique f\u00edsico do mouse conforme coordenadas X e Y informadas.\n\n    Parameters:\n        botao: valor str para o lado do bot\u00e3o a ser simulado. \\\n            Aceita valores 'ESQUERDO' e 'DIREITO'.\n        eixo_x: valor int para a posi\u00e7\u00e3o de coordenada X.\n        eixo_y: valor int para a posi\u00e7\u00e3o de coordenada Y.\n        tipo_clique: valor str para o tipo de clique a ser simulado. \\\n            Aceita valores 'UNICO' e 'DUPLO'.\n\n    Returns:\n        Retorna booleano, `True` caso tenha sucesso ao simular o clique, \\\n        `False` caso n\u00e3o tenha sucesso ao simular o clique.\n\n    Raises:\n        ValueError: Informe um bot\u00e3o v\u00e1lido: esquerdo, direito.\n        ValueError: Tipo de clique inv\u00e1lido, escolha entre \u00fanico e duplo.\n        ValueError: Coordenadas precisam ser do tipo inteiro .\n\n    Examples:\n        &gt;&gt;&gt; simular_clique(\n        ...     botao='ESQUERDO',\n        ...     eixo_x=valor_eixo_x,\n        ...     eixo_y=valor_eixo_y,\n        ...     tipo_clique='UNICO',\n        ... )\n        True\n    \"\"\"\n\n    # importa recursos do m\u00f3dulo mouse\n    from pywinauto.mouse import click, double_click\n\n    if not botao.upper() in ['ESQUERDO', 'DIREITO']:\n        raise ValueError('Informe um bot\u00e3o v\u00e1lido: esquerdo, direito.')\n\n    if not tipo_clique.upper() in ['UNICO', 'DUPLO']:\n        raise ValueError(\n            'Tipo de clique inv\u00e1lido, escolha entre \u00fanico e duplo.'\n        )\n\n    if (not isinstance(eixo_x, int)) or (not isinstance(eixo_y, int)):\n        raise ValueError('Coordenadas precisam ser do tipo inteiro .')\n\n    if botao.upper() == 'ESQUERDO':\n        botao = 'left'\n    else:\n        botao = 'right'\n\n    try:\n        if tipo_clique.upper() == 'UNICO':\n            click(button=botao, coords=(eixo_x, eixo_y))\n        else:\n            double_click(button=botao, coords=(eixo_x, eixo_y))\n\n        return True\n    except Exception:\n        return False\n</code></pre>"},{"location":"guia_usuario/desktop_utils/#simulando-digitacao-do-teclado","title":"Simulando digita\u00e7\u00e3o do teclado","text":"<p>H\u00e1 um recurso para disparar eventos de digita\u00e7\u00e3o do teclado em um ponto espec\u00edfico da tela, mediante coordenadas de eixo X e Y. As coordenadas precisam ser informadas em pixels e representam o posicionamento de pixels da tela. Para isso, utilize a fun\u00e7\u00e3o <code>simular_digitacao</code>.</p>"},{"location":"guia_usuario/desktop_utils/#funcao-simular_digitacao","title":"fun\u00e7\u00e3o simular_digitacao","text":"<p>Simula digita\u00e7\u00e3o do teclado, performando o teclado real.</p> <p>Parameters:</p> Name Type Description Default <code>texto</code> <code>str</code> <p>valor str para o valor do texto a ser digitado.             Aceita valores 'ESQUERDO' e 'DIREITO'.</p> required <code>com_espaco</code> <code>bool</code> <p>valor booleano, <code>True</code> para digitar com espa\u00e7os,             <code>False</code> para remover espa\u00e7os ao digitar.</p> <code>True</code> <code>com_tab</code> <code>bool</code> <p>valor booleano, <code>True</code> para digitar tab ao final             da digita\u00e7\u00e3o, <code>False</code> para n\u00e3o digitar tab ao final             da digita\u00e7\u00e3o.</p> <code>False</code> <code>com_linha_nova</code> <code>bool</code> <p>valor booleano, <code>True</code> para digitar linha             nova ao final da digita\u00e7\u00e3o, <code>False</code> para n\u00e3o digitar linha             nova ao final da digita\u00e7\u00e3o.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>Retorna booleano, <code>True</code> caso tenha sucesso ao simular             a digita\u00e7\u00e3o, <code>False</code> caso n\u00e3o tenha sucesso ao simular             a digita\u00e7\u00e3o.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Informe os par\u00e2metros com_espaco, com_tab e             com_linha_nova com valor boleano.</p> <code>ValueError</code> <p>Informe um texto do tipo string.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; simular_digitacao(\n...     texto = 'FGHIJ',\n...     com_espaco = True,\n...     com_tab = False,\n...     com_linha_nova = False,\n... )\nTrue\n</code></pre> Source code in <code>py_rpautom\\desktop_utils.py</code> <pre><code>def simular_digitacao(\n    texto: str,\n    com_espaco: bool = True,\n    com_tab: bool = False,\n    com_linha_nova: bool = False,\n) -&gt; bool:\n    \"\"\"Simula digita\u00e7\u00e3o do teclado, performando o teclado real.\n\n    Parameters:\n        texto: valor str para o valor do texto a ser digitado. \\\n            Aceita valores 'ESQUERDO' e 'DIREITO'.\n        com_espaco: valor booleano, `True` para digitar com espa\u00e7os, \\\n            `False` para remover espa\u00e7os ao digitar.\n        com_tab: valor booleano, `True` para digitar tab ao final \\\n            da digita\u00e7\u00e3o, `False` para n\u00e3o digitar tab ao final \\\n            da digita\u00e7\u00e3o.\n        com_linha_nova: valor booleano, `True` para digitar linha \\\n            nova ao final da digita\u00e7\u00e3o, `False` para n\u00e3o digitar linha \\\n            nova ao final da digita\u00e7\u00e3o.\n\n    Returns:\n        Retorna booleano, `True` caso tenha sucesso ao simular \\\n            a digita\u00e7\u00e3o, `False` caso n\u00e3o tenha sucesso ao simular \\\n            a digita\u00e7\u00e3o.\n\n    Raises:\n        ValueError: Informe os par\u00e2metros com_espaco, com_tab e \\\n            com_linha_nova com valor boleano.\n        ValueError: Informe um texto do tipo string.\n\n    Examples:\n        &gt;&gt;&gt; simular_digitacao(\n        ...     texto = 'FGHIJ',\n        ...     com_espaco = True,\n        ...     com_tab = False,\n        ...     com_linha_nova = False,\n        ... )\n        True\n    \"\"\"\n\n    # importa recursos do m\u00f3dulo keyboard\n    from pywinauto.keyboard import send_keys\n\n    if (\n        (not isinstance(com_espaco, bool))\n        or (not isinstance(com_tab, bool))\n        or (not isinstance(com_linha_nova, bool))\n    ):\n        raise ValueError(\n            \"\"\"Informe os par\u00e2metros com_espaco,\n                com_tab e com_linha_nova com valor boleano\"\"\"\n        )\n\n    if not isinstance(texto, str):\n        raise ValueError('Informe um texto do tipo string.')\n\n    try:\n        send_keys(\n            keys=texto,\n            with_spaces=com_espaco,\n            with_tabs=com_tab,\n            with_newlines=com_linha_nova,\n        )\n\n        return True\n    except:\n        return False\n</code></pre>"},{"location":"guia_usuario/python_utils/","title":"Guia de utilit\u00e1rios python","text":""},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-remover_acentos","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o remover_acentos","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\npyutils.cls()\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-remover_acentos_1","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o remover_acentos","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\ntexto = '''Jo\u00e3o come a\u00e7a\u00ed com o crach\u00e1 depois do trabalho. J\u00e1 Maria, joga domin\u00f3 ao voltar da escola para casa.\n \u00c0s vezes, parece que \u00e9 f\u00e1cil ouvir um \u00e1lbum de artistas c\u00e9lebres enquanto cria um gr\u00e1fico das \u00faltimas reuni\u00f5es.'''\npyutils.remover_acentos(\n    texto,\n    normalizacao='NFKD',\n)\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-logar","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o logar","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\nmensagem = 'Mensagem para log'\nnivel = 'INFO'\npyutils.logar( #\n    mensagem,\n    nivel,\n    arquivo=None,\n    modo=None,\n    encoding=None,\n    formatacao=None,\n    handlers=None,\n)\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-criar_pasta","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o criar_pasta","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\ncaminho = 'pasta_exemplo'\npyutils.criar_pasta(caminho)\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-criar_arquivo_texto","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o criar_arquivo_texto","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\ncaminho = 'arquivo_texto_exemplo.txt'\ndado='Dado de exemplo para arquivo de texto'\npyutils.criar_arquivo_texto (\n    caminho=caminho,\n    dado=dado,\n    encoding='utf8',\n    em_bytes = False,\n)\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-caminho_existente","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o caminho_existente","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\n# em caso de o caminho existir\ncaminho = 'arquivo_texto_exemplo.txt'\n\n# em caso de o caminho n\u00e3o existir\n# caminho = 'arquivo_textao_exemplo.txt'\n\npyutils.caminho_existente(caminho)\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-abrir_arquivo_texto","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o abrir_arquivo_texto","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\ncaminho = 'arquivo_texto_exemplo.txt'\npyutils.abrir_arquivo_texto(caminho, encoding='utf8')\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-abrir_arquivo_excel","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o abrir_arquivo_excel","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\narquivo_excel = 'arquivo_excel_exemplo.xlsx'\nguia = 'aba_exemplo'\npyutils.abrir_arquivo_excel(\n    arquivo_excel,\n    guia,\n    manter_macro = True,\n    manter_links = True,\n)\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-abrir_arquivo_word","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o abrir_arquivo_word","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\narquivo_word = 'arquivos_exemplo/arquivo_word_exemplo.docx'\npyutils.abrir_arquivo_word(arquivo_word = arquivo_word,)\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-abrir_arquivo_pdf","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o abrir_arquivo_pdf","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\narquivo_pdf = 'arquivos_exemplo/arquivo_pdf_exemplo.pdf'\n# ``paginacao`` aceita inteiro ou lista/tupla de inteiros,\n    # sendo que 0 corresponde \u00e0 todas as p\u00e1ginas\npaginacao = 0\n# ``orientacao`` aceita apenas inteiro, sendo um dos quatro valores seguintes:\n    # 0 (para cima),\n    # 90 (virado para a esquerda),\n    # 180 (de cabe\u00e7a para baixo),\n    # 270 (virado para a direita)\norientacao = 0,\npyutils.abrir_arquivo_pdf(\n    arquivo_pdf = arquivo_pdf,\n    senha_pdf = None,\n    paginacao = paginacao,\n    orientacao = orientacao,\n)\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-abrir_arquivo_em_bytes","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o abrir_arquivo_em_bytes","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\ncaminho = 'arquivos_exemplo/arquivo_pdf_exemplo.pdf'\npyutils.abrir_arquivo_em_bytes(caminho)\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-escrever_em_arquivo","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o escrever_em_arquivo","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\narquivo = 'arquivos_exemplo/arquivo_texto_exemplo.txt'\nconteudo = 'Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o escrever_em_arquivo'\nmodo='w'\npyutils.escrever_em_arquivo(\n    arquivo,\n    conteudo = conteudo,\n    modo = modo,\n    encoding='utf8',\n    nova_linha=None,\n)\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-gravar_log_em_arquivo","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o gravar_log_em_arquivo","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\narquivo = 'arquivos_exemplo/arquivo_texto_exemplo.txt'\nconteudo = ('Exemplo de c\u00f3digo', 'usando a fun\u00e7\u00e3o', 'gravar_log_em_arquivo\\n',)\nmodo='a'\npyutils.gravar_log_em_arquivo(\n    arquivo = arquivo,\n    conteudo = conteudo,\n    modo = modo,\n    encoding='utf8',\n    delimitador=';',\n    nova_linha='\\r\\n',\n)\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-coletar_nome_arquivo","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o coletar_nome_arquivo","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\ncaminho = 'arquivos_exemplo/arquivo_texto_exemplo.txt'\npyutils.coletar_nome_arquivo(caminho)\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-coletar_extensao_arquivo","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o coletar_extensao_arquivo","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\ncaminho = 'arquivos_exemplo/arquivo_texto_exemplo.txt'\npyutils.coletar_extensao_arquivo(caminho)\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-coletar_caminho_absoluto","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o coletar_caminho_absoluto","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\ncaminho = 'arquivos_exemplo/arquivo_texto_exemplo.txt'\npyutils.coletar_caminho_absoluto(caminho)\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-coletar_arvore_caminho","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o coletar_arvore_caminho","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\ncaminho = 'arquivos_exemplo/arquivo_texto_exemplo.txt'\npyutils.coletar_arvore_caminho(caminho)\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-coletar_nome_guias_arquivo_excel","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o coletar_nome_guias_arquivo_excel","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\narquivo_excel = 'arquivos_exemplo/arquivo_excel_exemplo.xlsx'\npyutils.coletar_nome_guias_arquivo_excel(arquivo_excel)\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-converter_pdf_em_imagem","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o converter_pdf_em_imagem","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\narquivo_pdf = 'arquivos_exemplo/arquivo_pdf_exemplo.pdf'\ncaminho_saida = 'arquivos_exemplo/caminho_retorno'\n# ``zoom`` aceita inteiro ou flutuante, sendo de 1 \u00e0 9.x, onde 1 \u00e9 o normal.\nzoom = 1\n# ``orientacao`` aceita apenas inteiro, sendo um dos quatro valores seguintes:\n    # 0 (para cima),\n    # 90 (virado para a esquerda),\n    # 180 (de cabe\u00e7a para baixo),\n    # 270 (virado para a direita)\norientacao = 0\npyutils.converter_pdf_em_imagem(\n    arquivo_pdf = arquivo_pdf,\n    caminho_saida = caminho_saida,\n    alpha = False,\n    zoom = zoom,\n    orientacao = orientacao,\n)\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-extrair_texto_ocr","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o extrair_texto_ocr","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\narquivo = 'arquivos_exemplo/caminho_retorno/arquivo_218.png'\nlinguagem = 'por'\npyutils.extrair_texto_ocr(arquivo, linguagem, encoding='utf8')\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-retornar_arquivos_em_pasta","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o retornar_arquivos_em_pasta","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\ncaminho = 'arquivos_exemplo/caminho_retorno/'\npyutils.retornar_arquivos_em_pasta(caminho, filtro='**/*')\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-retornar_data_hora_atual","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o retornar_data_hora_atual","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\nparametro = '%d_%m_%Y'\npyutils.retornar_data_hora_atual(parametro)\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-alterar_arquivo_texto","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o alterar_arquivo_texto","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\n# alterar_arquivo_texto substitui linhas inteiras\n#   onde a mesma cont\u00e9m o conte\u00fado fornecido pelo\n#   par\u00e2metro ``linha_atual``, e troca esse conte\u00fado\n#   pelo informado em ``linha_alterada``.\ncaminho = 'arquivos_exemplo/arquivo_texto_exemplo.txt'\nlinha_atual = 'Exemplo de c\u00f3digo;usando a fun\u00e7\u00e3o;gravar_log_em_arquivo'\nlinha_alterada = 'Texto alterado'\n# Par\u00e2metro ``multilinhas`` serve para substutuir todas as linhas\nmultilinhas = True\npyutils.alterar_arquivo_texto(\n    caminho = caminho,\n    linha_atual = linha_atual,\n    linha_alterada = linha_alterada,\n    multilinhas = multilinhas,\n    encoding_entrada='utf8',\n    encoding_saida='utf8',\n)\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-copiar_arquivo","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o copiar_arquivo","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\narquivo = 'arquivos_exemplo/arquivo_texto_exemplo.txt'\ncaminho_destino = 'arquivos_exemplo/caminho_retorno/'\npyutils.copiar_arquivo(arquivo, caminho_destino)\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-copiar_pasta","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o copiar_pasta","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\npasta = 'arquivos_exemplo/caminho_retorno'\ncaminho_destino = 'arquivos_exemplo/caminho_retorno/'\npyutils.copiar_pasta(pasta, caminho_destino)\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-renomear","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o renomear","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\ncaminho = './arquivos_exemplo/caminho_retorno/caminho_retorno'\nnome_atual = 'arquivo_1.png'\nnovo_nome = 'arquivo.png'\npyutils.renomear(caminho, nome_atual, novo_nome)\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-recortar","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o recortar","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\ncaminho_atual = 'arquivos_exemplo/caminho_retorno/caminho_retorno/arquivo.png'\ncaminho_novo = 'arquivos_exemplo/caminho_retorno/'\npyutils.recortar(caminho_atual, caminho_novo)\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-descompactar","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o descompactar","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\narquivo = 'atuacao_ole_siscob.zip'\ncaminho_destino = './arquivos_exemplo/'\npyutils.descompactar(arquivo, caminho_destino, senha_arquivo=None)\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-coletar_idioma_so","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o coletar_idioma_so","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\npyutils.coletar_idioma_so()\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-coletar_pid","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o coletar_pid","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\nnome_processo = 'msedge'\npyutils.coletar_pid(nome_processo)\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-ler_variavel_ambiente","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o ler_variavel_ambiente","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n# Esta fun\u00e7\u00e3o coleta valores de vari\u00e1veis, de sistema\n#   ou contido em um arquivo. Para caso queira usar em\n#   arquivo, defina um arquivo de configura\u00e7\u00e3o .ini e\n#   formate em blocos. Nesse caso, \u00e9 poss\u00edvel coletar o\n#   bloco inteiro ou apenas uma vari\u00e1vel do bloco. Para\n#   coletar o bloco inteiro, n\u00e3o defina o par\u00e2metro\n#   ``nome_variavel`` e caso queira exclusivamente uma\n#   vari\u00e1vel, a referencie nesse par\u00e2metro. Nos dois\n#   casos usando o arquivo \u00e9 preciso definir o par\u00e2metro\n#   ``nome_bloco_config``.\nnome_variavel='username'\nvariavel_sistema = True\npyutils.ler_variavel_ambiente(\n    arquivo_config='',\n    nome_bloco_config='',\n    nome_variavel = nome_variavel,\n    variavel_sistema = variavel_sistema,\n    encoding = 'utf8',\n)\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-processo_existente","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o processo_existente","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\nnome_processo = 'calc'\npyutils.processo_existente(nome_processo)\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-finalizar_processo","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o finalizar_processo","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\npid = 14464\npyutils.finalizar_processo(pid)\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-janela_dialogo","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o janela_dialogo","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\n# Cria uma janela de op\u00e7\u00f5es com bot\u00f5es como OK ou CANCEL, ou ainda ABORT.\n#   Essa janela tem como manipula\u00e7\u00e3o um objeto nativo do sistema, e por\n#   ent\u00e3o s\u00e3o apresentados elementos nativos. O retorno da fun\u00e7\u00e3o \u00e9 um\n#   inteiro correspondente \u00e0 op\u00e7\u00e3o selecionada.\n#   O par\u00e2metro ``estilo`` \u00e9 respons\u00e1vel pela escolha das op\u00e7\u00f5es de bot\u00f5es\n#   que dever\u00e3o aparecer, sendo necess\u00e1rio informar um n\u00famero de 0 \u00e0 6.\ntitulo = 'arquivo_pdf_exemplo.pdf'\ntexto = 'Arquivo de exemplo'\nestilo = 0\npyutils.janela_dialogo(titulo, texto, estilo)\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-excluir_arquivo","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o excluir_arquivo","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\ncaminho = 'arquivos_exemplo/caminho_retorno/arquivo.png'\npyutils.excluir_arquivo(caminho)\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-pasta_esta_vazia","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o pasta_esta_vazia","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\ncaminho = 'arquivos_exemplo/caminho_retorno/'\npyutils.pasta_esta_vazia(caminho = caminho)\n</code></pre>"},{"location":"guia_usuario/python_utils/#exemplo-de-codigo-usando-a-funcao-excluir_pasta","title":"Exemplo de c\u00f3digo usando a fun\u00e7\u00e3o excluir_pasta","text":"main.py<pre><code>from py_rpautom import python_utils as pyutils\n\n\ncaminho = 'arquivos_exemplo/caminho_retorno/'\nvazia = False\npyutils.excluir_pasta(caminho, vazia = vazia)\n</code></pre>"},{"location":"guia_usuario/web_utils/","title":"Guia de automa\u00e7\u00e3o web","text":"<p>Autentica em pop-ups de credenciais em navegador.</p> <p>Parameters:</p> Name Type Description Default <code>``usuario</code> <code>str)``</code> <p>String contendo usu\u00e1rio para digita\u00e7\u00e3o no campo correspondente.</p> required <code>``senha</code> <code>str)``</code> <p>String contendo senha para digita\u00e7\u00e3o no campo correspondente.</p> required <code>``caminho_janela</code> <code>dict)``</code> <p>dicion\u00e1rio contendo caminho at\u00e9 o t\u00edtulo do navegador.</p> required <code>``caminho_usuario</code> <code>dict)``</code> <p>dicion\u00e1rio contendo caminho at\u00e9 o elemento usu\u00e1rio no pop-up navegador.</p> required <code>``caminho_senha</code> <code>dict)``</code> <p>dicion\u00e1rio contendo caminho at\u00e9 o elemento senha no pop-up navegador.</p> required <code>``caminho_botao_aprovacao</code> <code>dict)``</code> <p>dicion\u00e1rio contendo caminho at\u00e9 o elemento bot\u00e3o de confirma\u00e7\u00e3o no pop-up navegador.</p> required <code>``pid_aplicacao</code> <code>int)``</code> <p>N\u00famero inteiro contendo o PID do navegador que cont\u00e9m o popup de autentica\u00e7\u00e3o.</p> required <code>``estilo_aplicacao</code> <code>str)``</code> <p>String contendo o estilo de aplica\u00e7\u00e3o entre uia e win32.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Retorna valor booleano. True for sucesso, False para erro na opera\u00e7\u00e3o de autenticar.</p> Source code in <code>py_rpautom\\web_utils.py</code> <pre><code>def autenticar_navegador(\n    usuario: str,\n    senha: str,\n    caminho_janela: dict,\n    caminho_usuario: dict,\n    caminho_senha: dict,\n    caminho_botao_aprovacao: dict,\n    pid_aplicacao: int,\n    estilo_aplicacao: str = 'uia',\n) -&gt; bool:\n    \"\"\"Autentica em pop-ups de credenciais em navegador.\n\n    Args:\n        ``usuario (str)``: String contendo usu\u00e1rio para digita\u00e7\u00e3o no campo correspondente.\n\n        ``senha (str)``: String contendo senha para digita\u00e7\u00e3o no campo correspondente.\n\n        ``caminho_janela (dict)``: dicion\u00e1rio contendo caminho at\u00e9 o t\u00edtulo do navegador.\n\n        ``caminho_usuario (dict)``: dicion\u00e1rio contendo caminho at\u00e9 o elemento usu\u00e1rio no pop-up navegador.\n\n        ``caminho_senha (dict)``: dicion\u00e1rio contendo caminho at\u00e9 o elemento senha no pop-up navegador.\n\n        ``caminho_botao_aprovacao (dict)``: dicion\u00e1rio contendo caminho at\u00e9 o elemento bot\u00e3o de confirma\u00e7\u00e3o no pop-up navegador.\n\n        ``pid_aplicacao (int)``: N\u00famero inteiro contendo o PID do navegador que cont\u00e9m o popup de autentica\u00e7\u00e3o.\n\n        ``estilo_aplicacao (str)``: String contendo o estilo de aplica\u00e7\u00e3o entre uia e win32.\n\n    Returns:\n        Retorna valor booleano. True for sucesso, False para erro na opera\u00e7\u00e3o de autenticar.\n    \"\"\"\n    # Validar o tipo da varivavel\n    if isinstance(usuario, str) is False:\n        raise ValueError('``usuario`` precisa ser do tipo str.')\n\n    if isinstance(senha, str) is False:\n        raise ValueError('``senha`` precisa ser do tipo str.')\n\n    if isinstance(caminho_janela, dict) is False:\n        raise ValueError('``caminho_janela`` precisa ser do tipo dict.')\n\n    if isinstance(caminho_usuario, dict) is False:\n        raise ValueError('``caminho_usuario`` precisa ser do tipo dict.')\n\n    if isinstance(caminho_senha, dict) is False:\n        raise ValueError('``caminho_senha`` precisa ser do tipo dict.')\n\n    if isinstance(caminho_botao_aprovacao, dict) is False:\n        raise ValueError(\n            '``caminho_botao_aprovacao`` precisa ser do tipo dict.'\n        )\n\n    if isinstance(pid_aplicacao, int) is False:\n        raise ValueError('``pid_aplicacao`` precisa ser do tipo int.')\n\n    if isinstance(estilo_aplicacao, str) is False:\n        raise ValueError('``estilo_aplicacao`` precisa ser do tipo str.')\n\n    desktop_utils.conectar_app(\n        pid_aplicacao,\n        estilo_aplicacao=estilo_aplicacao,\n        tempo_espera=1,\n    )\n\n    if (\n        desktop_utils.localizar_elemento(\n            caminho_campo=caminho_janela,\n            estilo_aplicacao=estilo_aplicacao,\n        )\n        is True\n    ):\n        desktop_utils.ativar_foco(nome_janela=caminho_janela)\n\n        desktop_utils.digitar(\n            caminho_campo=caminho_usuario,\n            valor=usuario,\n        )\n        desktop_utils.digitar(\n            caminho_campo=caminho_senha,\n            valor=senha,\n        )\n        desktop_utils.clicar(\n            caminho_campo=caminho_botao_aprovacao,\n        )\n\n        return True\n\n    return False\n</code></pre>"},{"location":"sobre/license/","title":"Licen\u00e7a","text":"<p>A biblioteca est\u00e1 sob os termos da licen\u00e7a GNU General Public License v3.0, conforme consta nesse link.</p>"}]}